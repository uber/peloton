#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style,slots,utf8strings
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class ResponseCode(object):
  INVALID_REQUEST = 0
  OK = 1
  ERROR = 2
  WARNING = 3
  AUTH_FAILED = 4
  LOCK_ERROR = 5
  ERROR_TRANSIENT = 6

  _VALUES_TO_NAMES = {
    0: "INVALID_REQUEST",
    1: "OK",
    2: "ERROR",
    3: "WARNING",
    4: "AUTH_FAILED",
    5: "LOCK_ERROR",
    6: "ERROR_TRANSIENT",
  }

  _NAMES_TO_VALUES = {
    "INVALID_REQUEST": 0,
    "OK": 1,
    "ERROR": 2,
    "WARNING": 3,
    "AUTH_FAILED": 4,
    "LOCK_ERROR": 5,
    "ERROR_TRANSIENT": 6,
  }

class MaintenanceMode(object):
  NONE = 1
  SCHEDULED = 2
  DRAINING = 3
  DRAINED = 4

  _VALUES_TO_NAMES = {
    1: "NONE",
    2: "SCHEDULED",
    3: "DRAINING",
    4: "DRAINED",
  }

  _NAMES_TO_VALUES = {
    "NONE": 1,
    "SCHEDULED": 2,
    "DRAINING": 3,
    "DRAINED": 4,
  }

class Mode(object):
  """
  The mode for a volume mount
  """
  RW = 1
  RO = 2

  _VALUES_TO_NAMES = {
    1: "RW",
    2: "RO",
  }

  _NAMES_TO_VALUES = {
    "RW": 1,
    "RO": 2,
  }

class CronCollisionPolicy(object):
  """
  Defines the policy for launching a new cron job when one is already running.
  """
  KILL_EXISTING = 0
  CANCEL_NEW = 1
  RUN_OVERLAP = 2

  _VALUES_TO_NAMES = {
    0: "KILL_EXISTING",
    1: "CANCEL_NEW",
    2: "RUN_OVERLAP",
  }

  _NAMES_TO_VALUES = {
    "KILL_EXISTING": 0,
    "CANCEL_NEW": 1,
    "RUN_OVERLAP": 2,
  }

class ScheduleStatus(object):
  """
  States that a task may be in.
  """
  INIT = 11
  THROTTLED = 16
  PENDING = 0
  ASSIGNED = 9
  STARTING = 1
  RUNNING = 2
  FINISHED = 3
  PREEMPTING = 13
  RESTARTING = 12
  DRAINING = 17
  FAILED = 4
  KILLED = 5
  KILLING = 6
  LOST = 7

  _VALUES_TO_NAMES = {
    11: "INIT",
    16: "THROTTLED",
    0: "PENDING",
    9: "ASSIGNED",
    1: "STARTING",
    2: "RUNNING",
    3: "FINISHED",
    13: "PREEMPTING",
    12: "RESTARTING",
    17: "DRAINING",
    4: "FAILED",
    5: "KILLED",
    6: "KILLING",
    7: "LOST",
  }

  _NAMES_TO_VALUES = {
    "INIT": 11,
    "THROTTLED": 16,
    "PENDING": 0,
    "ASSIGNED": 9,
    "STARTING": 1,
    "RUNNING": 2,
    "FINISHED": 3,
    "PREEMPTING": 13,
    "RESTARTING": 12,
    "DRAINING": 17,
    "FAILED": 4,
    "KILLED": 5,
    "KILLING": 6,
    "LOST": 7,
  }

class JobUpdateStatus(object):
  """
  States that a job update may be in.
  """
  ROLLING_FORWARD = 0
  ROLLING_BACK = 1
  ROLL_FORWARD_PAUSED = 2
  ROLL_BACK_PAUSED = 3
  ROLLED_FORWARD = 4
  ROLLED_BACK = 5
  ABORTED = 6
  ERROR = 7
  FAILED = 8
  ROLL_FORWARD_AWAITING_PULSE = 9
  ROLL_BACK_AWAITING_PULSE = 10

  _VALUES_TO_NAMES = {
    0: "ROLLING_FORWARD",
    1: "ROLLING_BACK",
    2: "ROLL_FORWARD_PAUSED",
    3: "ROLL_BACK_PAUSED",
    4: "ROLLED_FORWARD",
    5: "ROLLED_BACK",
    6: "ABORTED",
    7: "ERROR",
    8: "FAILED",
    9: "ROLL_FORWARD_AWAITING_PULSE",
    10: "ROLL_BACK_AWAITING_PULSE",
  }

  _NAMES_TO_VALUES = {
    "ROLLING_FORWARD": 0,
    "ROLLING_BACK": 1,
    "ROLL_FORWARD_PAUSED": 2,
    "ROLL_BACK_PAUSED": 3,
    "ROLLED_FORWARD": 4,
    "ROLLED_BACK": 5,
    "ABORTED": 6,
    "ERROR": 7,
    "FAILED": 8,
    "ROLL_FORWARD_AWAITING_PULSE": 9,
    "ROLL_BACK_AWAITING_PULSE": 10,
  }

class JobUpdateAction(object):
  """
  Job update actions that can be applied to job instances.
  """
  INSTANCE_UPDATED = 1
  INSTANCE_ROLLED_BACK = 2
  INSTANCE_UPDATING = 3
  INSTANCE_ROLLING_BACK = 4
  INSTANCE_UPDATE_FAILED = 5
  INSTANCE_ROLLBACK_FAILED = 6

  _VALUES_TO_NAMES = {
    1: "INSTANCE_UPDATED",
    2: "INSTANCE_ROLLED_BACK",
    3: "INSTANCE_UPDATING",
    4: "INSTANCE_ROLLING_BACK",
    5: "INSTANCE_UPDATE_FAILED",
    6: "INSTANCE_ROLLBACK_FAILED",
  }

  _NAMES_TO_VALUES = {
    "INSTANCE_UPDATED": 1,
    "INSTANCE_ROLLED_BACK": 2,
    "INSTANCE_UPDATING": 3,
    "INSTANCE_ROLLING_BACK": 4,
    "INSTANCE_UPDATE_FAILED": 5,
    "INSTANCE_ROLLBACK_FAILED": 6,
  }

class JobUpdatePulseStatus(object):
  """
  Status of the coordinated update. Intended as a response to pulseJobUpdate RPC.
  """
  OK = 1
  FINISHED = 2

  _VALUES_TO_NAMES = {
    1: "OK",
    2: "FINISHED",
  }

  _NAMES_TO_VALUES = {
    "OK": 1,
    "FINISHED": 2,
  }


class Identity(object):
  """
  Attributes:
   - user
  """

  __slots__ = [ 
    'user',
   ]

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.STRING, 'user', None, None, ), # 2
  )

  def __init__(self, user=None,):
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.STRING:
          self.user = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Identity')
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 2)
      oprot.writeString(self.user.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class Attribute(object):
  """
  A single host attribute.

  Attributes:
   - name
   - values
  """

  __slots__ = [ 
    'name',
    'values',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.SET, 'values', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, name=None, values=None,):
    self.name = name
    self.values = values

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.SET:
          self.values = set()
          (_etype3, _size0) = iprot.readSetBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readString().decode('utf-8')
            self.values.add(_elem5)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Attribute')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.SET, 2)
      oprot.writeSetBegin(TType.STRING, len(self.values))
      for iter6 in self.values:
        oprot.writeString(iter6.encode('utf-8'))
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class HostAttributes(object):
  """
  The attributes assigned to a host.

  Attributes:
   - host
   - attributes
   - mode
   - slaveId
  """

  __slots__ = [ 
    'host',
    'attributes',
    'mode',
    'slaveId',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'host', None, None, ), # 1
    (2, TType.SET, 'attributes', (TType.STRUCT,(Attribute, Attribute.thrift_spec)), None, ), # 2
    (3, TType.I32, 'mode', None, None, ), # 3
    (4, TType.STRING, 'slaveId', None, None, ), # 4
  )

  def __init__(self, host=None, attributes=None, mode=None, slaveId=None,):
    self.host = host
    self.attributes = attributes
    self.mode = mode
    self.slaveId = slaveId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.host = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.SET:
          self.attributes = set()
          (_etype10, _size7) = iprot.readSetBegin()
          for _i11 in xrange(_size7):
            _elem12 = Attribute()
            _elem12.read(iprot)
            self.attributes.add(_elem12)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.mode = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.slaveId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('HostAttributes')
    if self.host is not None:
      oprot.writeFieldBegin('host', TType.STRING, 1)
      oprot.writeString(self.host.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.SET, 2)
      oprot.writeSetBegin(TType.STRUCT, len(self.attributes))
      for iter13 in self.attributes:
        iter13.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.mode is not None:
      oprot.writeFieldBegin('mode', TType.I32, 3)
      oprot.writeI32(self.mode)
      oprot.writeFieldEnd()
    if self.slaveId is not None:
      oprot.writeFieldBegin('slaveId', TType.STRING, 4)
      oprot.writeString(self.slaveId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class ValueConstraint(object):
  """
  A constraint that specifies an explicit set of values, at least one of which must be present
  on a host for a task to be scheduled there.

  Attributes:
   - negated: If true, treat this as a 'not' - to avoid specific values.
   - values
  """

  __slots__ = [ 
    'negated',
    'values',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'negated', None, None, ), # 1
    (2, TType.SET, 'values', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, negated=None, values=None,):
    self.negated = negated
    self.values = values

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.negated = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.SET:
          self.values = set()
          (_etype17, _size14) = iprot.readSetBegin()
          for _i18 in xrange(_size14):
            _elem19 = iprot.readString().decode('utf-8')
            self.values.add(_elem19)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ValueConstraint')
    if self.negated is not None:
      oprot.writeFieldBegin('negated', TType.BOOL, 1)
      oprot.writeBool(self.negated)
      oprot.writeFieldEnd()
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.SET, 2)
      oprot.writeSetBegin(TType.STRING, len(self.values))
      for iter20 in self.values:
        oprot.writeString(iter20.encode('utf-8'))
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class LimitConstraint(object):
  """
  A constraint the specifies the maximum number of active tasks on a host with a matching
  attribute that may be scheduled simultaneously.

  Attributes:
   - limit
  """

  __slots__ = [ 
    'limit',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'limit', None, None, ), # 1
  )

  def __init__(self, limit=None,):
    self.limit = limit

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.limit = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LimitConstraint')
    if self.limit is not None:
      oprot.writeFieldBegin('limit', TType.I32, 1)
      oprot.writeI32(self.limit)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class TaskConstraint(object):
  """
  Types of constraints that may be applied to a task.

  Attributes:
   - value
   - limit
  """

  __slots__ = [ 
    'value',
    'limit',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'value', (ValueConstraint, ValueConstraint.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'limit', (LimitConstraint, LimitConstraint.thrift_spec), None, ), # 2
  )

  def __init__(self, value=None, limit=None,):
    self.value = value
    self.limit = limit

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.value = ValueConstraint()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.limit = LimitConstraint()
          self.limit.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TaskConstraint')
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 1)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.limit is not None:
      oprot.writeFieldBegin('limit', TType.STRUCT, 2)
      self.limit.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class Constraint(object):
  """
  A constraint that defines whether a task may be scheduled on a host.

  Attributes:
   - name: Mesos slave attribute that the constraint is matched against.
   - constraint
  """

  __slots__ = [ 
    'name',
    'constraint',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRUCT, 'constraint', (TaskConstraint, TaskConstraint.thrift_spec), None, ), # 2
  )

  def __init__(self, name=None, constraint=None,):
    self.name = name
    self.constraint = constraint

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.constraint = TaskConstraint()
          self.constraint.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Constraint')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.constraint is not None:
      oprot.writeFieldBegin('constraint', TType.STRUCT, 2)
      self.constraint.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class Package(object):
  """
  Attributes:
   - role
   - name
   - version
  """

  __slots__ = [ 
    'role',
    'name',
    'version',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'role', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    (3, TType.I32, 'version', None, None, ), # 3
  )

  def __init__(self, role=None, name=None, version=None,):
    self.role = role
    self.name = name
    self.version = version

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.role = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.version = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Package')
    if self.role is not None:
      oprot.writeFieldBegin('role', TType.STRING, 1)
      oprot.writeString(self.role.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.I32, 3)
      oprot.writeI32(self.version)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class Metadata(object):
  """
  Arbitrary key-value metadata to be included into TaskConfig.

  Attributes:
   - key
   - value
  """

  __slots__ = [ 
    'key',
    'value',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'value', None, None, ), # 2
  )

  def __init__(self, key=None, value=None,):
    self.key = key
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.value = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Metadata')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 2)
      oprot.writeString(self.value.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class JobKey(object):
  """
  A unique identifier for a Job.

  Attributes:
   - role: User role (Unix service account), for example "mesos"
   - environment: Environment, for example "devel"
   - name: Name, for example "labrat"
  """

  __slots__ = [ 
    'role',
    'environment',
    'name',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'role', None, None, ), # 1
    (2, TType.STRING, 'environment', None, None, ), # 2
    (3, TType.STRING, 'name', None, None, ), # 3
  )

  def __init__(self, role=None, environment=None, name=None,):
    self.role = role
    self.environment = environment
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.role = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.environment = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JobKey')
    if self.role is not None:
      oprot.writeFieldBegin('role', TType.STRING, 1)
      oprot.writeString(self.role.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 2)
      oprot.writeString(self.environment.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 3)
      oprot.writeString(self.name.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class LockKey(object):
  """
  A unique lock key.

  Attributes:
   - job
  """

  __slots__ = [ 
    'job',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'job', (JobKey, JobKey.thrift_spec), None, ), # 1
  )

  def __init__(self, job=None,):
    self.job = job

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.job = JobKey()
          self.job.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LockKey')
    if self.job is not None:
      oprot.writeFieldBegin('job', TType.STRUCT, 1)
      self.job.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class Lock(object):
  """
  A generic lock struct to facilitate context specific resource/operation serialization.

  Attributes:
   - key: ID of the lock - unique per storage
   - token: UUID - facilitating soft lock authorization
   - user: Lock creator
   - timestampMs: Lock creation timestamp in milliseconds
   - message: Optional message to record with the lock
  """

  __slots__ = [ 
    'key',
    'token',
    'user',
    'timestampMs',
    'message',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'key', (LockKey, LockKey.thrift_spec), None, ), # 1
    (2, TType.STRING, 'token', None, None, ), # 2
    (3, TType.STRING, 'user', None, None, ), # 3
    (4, TType.I64, 'timestampMs', None, None, ), # 4
    (5, TType.STRING, 'message', None, None, ), # 5
  )

  def __init__(self, key=None, token=None, user=None, timestampMs=None, message=None,):
    self.key = key
    self.token = token
    self.user = user
    self.timestampMs = timestampMs
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.key = LockKey()
          self.key.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.token = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.user = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.timestampMs = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.message = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Lock')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRUCT, 1)
      self.key.write(oprot)
      oprot.writeFieldEnd()
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 2)
      oprot.writeString(self.token.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 3)
      oprot.writeString(self.user.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.timestampMs is not None:
      oprot.writeFieldBegin('timestampMs', TType.I64, 4)
      oprot.writeI64(self.timestampMs)
      oprot.writeFieldEnd()
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 5)
      oprot.writeString(self.message.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class InstanceKey(object):
  """
  A unique identifier for the active task within a job.

  Attributes:
   - jobKey: Key identifying the job.
   - instanceId: Unique instance ID for the active task in a job.
  """

  __slots__ = [ 
    'jobKey',
    'instanceId',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'jobKey', (JobKey, JobKey.thrift_spec), None, ), # 1
    (2, TType.I32, 'instanceId', None, None, ), # 2
  )

  def __init__(self, jobKey=None, instanceId=None,):
    self.jobKey = jobKey
    self.instanceId = instanceId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.jobKey = JobKey()
          self.jobKey.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.instanceId = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InstanceKey')
    if self.jobKey is not None:
      oprot.writeFieldBegin('jobKey', TType.STRUCT, 1)
      self.jobKey.write(oprot)
      oprot.writeFieldEnd()
    if self.instanceId is not None:
      oprot.writeFieldBegin('instanceId', TType.I32, 2)
      oprot.writeI32(self.instanceId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class MesosFetcherURI(object):
  """
  URI which mirrors CommandInfo.URI in the Mesos Protobuf

  Attributes:
   - value: Where to get the resource from
   - extract: Extract compressed archive after downloading
   - cache: Cache value using Mesos Fetcher caching mechanism *
  """

  __slots__ = [ 
    'value',
    'extract',
    'cache',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'value', None, None, ), # 1
    (2, TType.BOOL, 'extract', None, None, ), # 2
    (3, TType.BOOL, 'cache', None, None, ), # 3
  )

  def __init__(self, value=None, extract=None, cache=None,):
    self.value = value
    self.extract = extract
    self.cache = cache

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.value = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.extract = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.cache = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MesosFetcherURI')
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 1)
      oprot.writeString(self.value.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.extract is not None:
      oprot.writeFieldBegin('extract', TType.BOOL, 2)
      oprot.writeBool(self.extract)
      oprot.writeFieldEnd()
    if self.cache is not None:
      oprot.writeFieldBegin('cache', TType.BOOL, 3)
      oprot.writeBool(self.cache)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class ExecutorConfig(object):
  """
  Attributes:
   - name: Name identifying the Executor.
   - data: Executor configuration data.
  """

  __slots__ = [ 
    'name',
    'data',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'data', None, None, ), # 2
  )

  def __init__(self, name=None, data=None,):
    self.name = name
    self.data = data

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.data = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ExecutorConfig')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.data is not None:
      oprot.writeFieldBegin('data', TType.STRING, 2)
      oprot.writeString(self.data.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class Volume(object):
  """
  A volume mount point within a container

  Attributes:
   - containerPath: The path inside the container where the mount will be created.
   - hostPath: The path on the host that will serve as the source for the mount.
   - mode: The access mode
  """

  __slots__ = [ 
    'containerPath',
    'hostPath',
    'mode',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'containerPath', None, None, ), # 1
    (2, TType.STRING, 'hostPath', None, None, ), # 2
    (3, TType.I32, 'mode', None, None, ), # 3
  )

  def __init__(self, containerPath=None, hostPath=None, mode=None,):
    self.containerPath = containerPath
    self.hostPath = hostPath
    self.mode = mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.containerPath = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.hostPath = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.mode = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Volume')
    if self.containerPath is not None:
      oprot.writeFieldBegin('containerPath', TType.STRING, 1)
      oprot.writeString(self.containerPath.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.hostPath is not None:
      oprot.writeFieldBegin('hostPath', TType.STRING, 2)
      oprot.writeString(self.hostPath.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.mode is not None:
      oprot.writeFieldBegin('mode', TType.I32, 3)
      oprot.writeI32(self.mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class DockerImage(object):
  """
  Describes an image for use with the Mesos unified containerizer in the Docker format

  Attributes:
   - name: The name of the image to run
   - tag: The Docker tag identifying the image
  """

  __slots__ = [ 
    'name',
    'tag',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'tag', None, None, ), # 2
  )

  def __init__(self, name=None, tag=None,):
    self.name = name
    self.tag = tag

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tag = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DockerImage')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.tag is not None:
      oprot.writeFieldBegin('tag', TType.STRING, 2)
      oprot.writeString(self.tag.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class AppcImage(object):
  """
  Describes an image for use with the Mesos unified containerizer in the AppC format

  Attributes:
   - name: The name of the image to run
   - imageId: The appc image id identifying the image
  """

  __slots__ = [ 
    'name',
    'imageId',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'imageId', None, None, ), # 2
  )

  def __init__(self, name=None, imageId=None,):
    self.name = name
    self.imageId = imageId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.imageId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AppcImage')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.imageId is not None:
      oprot.writeFieldBegin('imageId', TType.STRING, 2)
      oprot.writeString(self.imageId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class Image(object):
  """
  Describes an image to be used with the Mesos unified containerizer

  Attributes:
   - docker
   - appc
  """

  __slots__ = [ 
    'docker',
    'appc',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'docker', (DockerImage, DockerImage.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'appc', (AppcImage, AppcImage.thrift_spec), None, ), # 2
  )

  def __init__(self, docker=None, appc=None,):
    self.docker = docker
    self.appc = appc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.docker = DockerImage()
          self.docker.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.appc = AppcImage()
          self.appc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Image')
    if self.docker is not None:
      oprot.writeFieldBegin('docker', TType.STRUCT, 1)
      self.docker.write(oprot)
      oprot.writeFieldEnd()
    if self.appc is not None:
      oprot.writeFieldBegin('appc', TType.STRUCT, 2)
      self.appc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class MesosContainer(object):
  """
  Describes a mesos container, this is the default

  Attributes:
   - image: the optional filesystem image to use when launching this task.
   - volumes: the optional list of volumes to mount into the task.
  """

  __slots__ = [ 
    'image',
    'volumes',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'image', (Image, Image.thrift_spec), None, ), # 1
    (2, TType.LIST, 'volumes', (TType.STRUCT,(Volume, Volume.thrift_spec)), None, ), # 2
  )

  def __init__(self, image=None, volumes=None,):
    self.image = image
    self.volumes = volumes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.image = Image()
          self.image.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.volumes = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = Volume()
            _elem26.read(iprot)
            self.volumes.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MesosContainer')
    if self.image is not None:
      oprot.writeFieldBegin('image', TType.STRUCT, 1)
      self.image.write(oprot)
      oprot.writeFieldEnd()
    if self.volumes is not None:
      oprot.writeFieldBegin('volumes', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.volumes))
      for iter27 in self.volumes:
        iter27.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class DockerParameter(object):
  """
  Describes a parameter passed to docker cli

  Attributes:
   - name: a parameter to pass to docker. (e.g. volume)
   - value: the value to pass to a parameter (e.g. /src/webapp:/opt/webapp)
  """

  __slots__ = [ 
    'name',
    'value',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'value', None, None, ), # 2
  )

  def __init__(self, name=None, value=None,):
    self.name = name
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.value = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DockerParameter')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 2)
      oprot.writeString(self.value.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class DockerContainer(object):
  """
  Describes a docker container

  Attributes:
   - image: The container image to be run
   - parameters: The arbitrary parameters to pass to container
  """

  __slots__ = [ 
    'image',
    'parameters',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'image', None, None, ), # 1
    (2, TType.LIST, 'parameters', (TType.STRUCT,(DockerParameter, DockerParameter.thrift_spec)), None, ), # 2
  )

  def __init__(self, image=None, parameters=None,):
    self.image = image
    self.parameters = parameters

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.image = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.parameters = []
          (_etype31, _size28) = iprot.readListBegin()
          for _i32 in xrange(_size28):
            _elem33 = DockerParameter()
            _elem33.read(iprot)
            self.parameters.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DockerContainer')
    if self.image is not None:
      oprot.writeFieldBegin('image', TType.STRING, 1)
      oprot.writeString(self.image.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.parameters))
      for iter34 in self.parameters:
        iter34.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class Container(object):
  """
  Describes a container to be used in a task

  Attributes:
   - mesos
   - docker
  """

  __slots__ = [ 
    'mesos',
    'docker',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'mesos', (MesosContainer, MesosContainer.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'docker', (DockerContainer, DockerContainer.thrift_spec), None, ), # 2
  )

  def __init__(self, mesos=None, docker=None,):
    self.mesos = mesos
    self.docker = docker

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.mesos = MesosContainer()
          self.mesos.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.docker = DockerContainer()
          self.docker.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Container')
    if self.mesos is not None:
      oprot.writeFieldBegin('mesos', TType.STRUCT, 1)
      self.mesos.write(oprot)
      oprot.writeFieldEnd()
    if self.docker is not None:
      oprot.writeFieldBegin('docker', TType.STRUCT, 2)
      self.docker.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class Resource(object):
  """
  Describes resource value required to run a task.

  Attributes:
   - numCpus
   - ramMb
   - diskMb
   - namedPort
   - numGpus
  """

  __slots__ = [ 
    'numCpus',
    'ramMb',
    'diskMb',
    'namedPort',
    'numGpus',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.DOUBLE, 'numCpus', None, None, ), # 1
    (2, TType.I64, 'ramMb', None, None, ), # 2
    (3, TType.I64, 'diskMb', None, None, ), # 3
    (4, TType.STRING, 'namedPort', None, None, ), # 4
    (5, TType.I64, 'numGpus', None, None, ), # 5
  )

  def __init__(self, numCpus=None, ramMb=None, diskMb=None, namedPort=None, numGpus=None,):
    self.numCpus = numCpus
    self.ramMb = ramMb
    self.diskMb = diskMb
    self.namedPort = namedPort
    self.numGpus = numGpus

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          self.numCpus = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.ramMb = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.diskMb = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.namedPort = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.numGpus = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Resource')
    if self.numCpus is not None:
      oprot.writeFieldBegin('numCpus', TType.DOUBLE, 1)
      oprot.writeDouble(self.numCpus)
      oprot.writeFieldEnd()
    if self.ramMb is not None:
      oprot.writeFieldBegin('ramMb', TType.I64, 2)
      oprot.writeI64(self.ramMb)
      oprot.writeFieldEnd()
    if self.diskMb is not None:
      oprot.writeFieldBegin('diskMb', TType.I64, 3)
      oprot.writeI64(self.diskMb)
      oprot.writeFieldEnd()
    if self.namedPort is not None:
      oprot.writeFieldBegin('namedPort', TType.STRING, 4)
      oprot.writeString(self.namedPort.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.numGpus is not None:
      oprot.writeFieldBegin('numGpus', TType.I64, 5)
      oprot.writeI64(self.numGpus)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class TaskConfig(object):
  """
  Description of the tasks contained within a job.

  Attributes:
   - job: Job task belongs to.
   - owner: contains the role component of JobKey
   - isService
   - numCpus
   - ramMb
   - diskMb
   - priority
   - maxTaskFailures
   - production: Whether this is a production task, which can preempt.
   - tier: Task tier type.
   - resources: All resources required to run a task.
   - constraints
   - requestedPorts: a list of named ports this task requests
   - mesosFetcherUris: Resources to retrieve with Mesos Fetcher
   - taskLinks: Custom links to include when displaying this task on the scheduler dashboard. Keys are anchor
  text, values are URLs. Wildcards are supported for dynamic link crafting based on host, ports,
  instance, etc.
   - contactEmail
   - executorConfig: Executor configuration
   - metadata: Used to display additional details in the UI.
   - container: the container the task should use to execute
  """

  __slots__ = [ 
    'isService',
    'numCpus',
    'ramMb',
    'diskMb',
    'priority',
    'maxTaskFailures',
    'owner',
    'production',
    'constraints',
    'requestedPorts',
    'taskLinks',
    'contactEmail',
    'executorConfig',
    'metadata',
    'job',
    'container',
    'tier',
    'resources',
    'mesosFetcherUris',
   ]

  thrift_spec = (
    None, # 0
    None, # 1
    None, # 2
    None, # 3
    None, # 4
    None, # 5
    None, # 6
    (7, TType.BOOL, 'isService', None, None, ), # 7
    (8, TType.DOUBLE, 'numCpus', None, None, ), # 8
    (9, TType.I64, 'ramMb', None, None, ), # 9
    (10, TType.I64, 'diskMb', None, None, ), # 10
    (11, TType.I32, 'priority', None, None, ), # 11
    None, # 12
    (13, TType.I32, 'maxTaskFailures', None, None, ), # 13
    None, # 14
    None, # 15
    None, # 16
    (17, TType.STRUCT, 'owner', (Identity, Identity.thrift_spec), None, ), # 17
    (18, TType.BOOL, 'production', None, None, ), # 18
    None, # 19
    (20, TType.SET, 'constraints', (TType.STRUCT,(Constraint, Constraint.thrift_spec)), None, ), # 20
    (21, TType.SET, 'requestedPorts', (TType.STRING,None), None, ), # 21
    (22, TType.MAP, 'taskLinks', (TType.STRING,None,TType.STRING,None), None, ), # 22
    (23, TType.STRING, 'contactEmail', None, None, ), # 23
    None, # 24
    (25, TType.STRUCT, 'executorConfig', (ExecutorConfig, ExecutorConfig.thrift_spec), None, ), # 25
    None, # 26
    (27, TType.SET, 'metadata', (TType.STRUCT,(Metadata, Metadata.thrift_spec)), None, ), # 27
    (28, TType.STRUCT, 'job', (JobKey, JobKey.thrift_spec), None, ), # 28
    (29, TType.STRUCT, 'container', (Container, Container.thrift_spec), Container(**{
      "mesos" : MesosContainer(**{
      }),
    }), ), # 29
    (30, TType.STRING, 'tier', None, None, ), # 30
    None, # 31
    (32, TType.SET, 'resources', (TType.STRUCT,(Resource, Resource.thrift_spec)), None, ), # 32
    (33, TType.SET, 'mesosFetcherUris', (TType.STRUCT,(MesosFetcherURI, MesosFetcherURI.thrift_spec)), None, ), # 33
  )

  def __init__(self, job=None, owner=None, isService=None, numCpus=None, ramMb=None, diskMb=None, priority=None, maxTaskFailures=None, production=None, tier=None, resources=None, constraints=None, requestedPorts=None, mesosFetcherUris=None, taskLinks=None, contactEmail=None, executorConfig=None, metadata=None, container=thrift_spec[29][4],):
    self.job = job
    self.owner = owner
    self.isService = isService
    self.numCpus = numCpus
    self.ramMb = ramMb
    self.diskMb = diskMb
    self.priority = priority
    self.maxTaskFailures = maxTaskFailures
    self.production = production
    self.tier = tier
    self.resources = resources
    self.constraints = constraints
    self.requestedPorts = requestedPorts
    self.mesosFetcherUris = mesosFetcherUris
    self.taskLinks = taskLinks
    self.contactEmail = contactEmail
    self.executorConfig = executorConfig
    self.metadata = metadata
    if container is self.thrift_spec[29][4]:
      container = Container(**{
      "mesos" : MesosContainer(**{
      }),
    })
    self.container = container

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 28:
        if ftype == TType.STRUCT:
          self.job = JobKey()
          self.job.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.STRUCT:
          self.owner = Identity()
          self.owner.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.isService = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.DOUBLE:
          self.numCpus = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I64:
          self.ramMb = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I64:
          self.diskMb = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I32:
          self.priority = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.I32:
          self.maxTaskFailures = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.BOOL:
          self.production = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 30:
        if ftype == TType.STRING:
          self.tier = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 32:
        if ftype == TType.SET:
          self.resources = set()
          (_etype38, _size35) = iprot.readSetBegin()
          for _i39 in xrange(_size35):
            _elem40 = Resource()
            _elem40.read(iprot)
            self.resources.add(_elem40)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.SET:
          self.constraints = set()
          (_etype44, _size41) = iprot.readSetBegin()
          for _i45 in xrange(_size41):
            _elem46 = Constraint()
            _elem46.read(iprot)
            self.constraints.add(_elem46)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 21:
        if ftype == TType.SET:
          self.requestedPorts = set()
          (_etype50, _size47) = iprot.readSetBegin()
          for _i51 in xrange(_size47):
            _elem52 = iprot.readString().decode('utf-8')
            self.requestedPorts.add(_elem52)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 33:
        if ftype == TType.SET:
          self.mesosFetcherUris = set()
          (_etype56, _size53) = iprot.readSetBegin()
          for _i57 in xrange(_size53):
            _elem58 = MesosFetcherURI()
            _elem58.read(iprot)
            self.mesosFetcherUris.add(_elem58)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 22:
        if ftype == TType.MAP:
          self.taskLinks = {}
          (_ktype60, _vtype61, _size59 ) = iprot.readMapBegin()
          for _i63 in xrange(_size59):
            _key64 = iprot.readString().decode('utf-8')
            _val65 = iprot.readString().decode('utf-8')
            self.taskLinks[_key64] = _val65
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 23:
        if ftype == TType.STRING:
          self.contactEmail = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 25:
        if ftype == TType.STRUCT:
          self.executorConfig = ExecutorConfig()
          self.executorConfig.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 27:
        if ftype == TType.SET:
          self.metadata = set()
          (_etype69, _size66) = iprot.readSetBegin()
          for _i70 in xrange(_size66):
            _elem71 = Metadata()
            _elem71.read(iprot)
            self.metadata.add(_elem71)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 29:
        if ftype == TType.STRUCT:
          self.container = Container()
          self.container.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TaskConfig')
    if self.isService is not None:
      oprot.writeFieldBegin('isService', TType.BOOL, 7)
      oprot.writeBool(self.isService)
      oprot.writeFieldEnd()
    if self.numCpus is not None:
      oprot.writeFieldBegin('numCpus', TType.DOUBLE, 8)
      oprot.writeDouble(self.numCpus)
      oprot.writeFieldEnd()
    if self.ramMb is not None:
      oprot.writeFieldBegin('ramMb', TType.I64, 9)
      oprot.writeI64(self.ramMb)
      oprot.writeFieldEnd()
    if self.diskMb is not None:
      oprot.writeFieldBegin('diskMb', TType.I64, 10)
      oprot.writeI64(self.diskMb)
      oprot.writeFieldEnd()
    if self.priority is not None:
      oprot.writeFieldBegin('priority', TType.I32, 11)
      oprot.writeI32(self.priority)
      oprot.writeFieldEnd()
    if self.maxTaskFailures is not None:
      oprot.writeFieldBegin('maxTaskFailures', TType.I32, 13)
      oprot.writeI32(self.maxTaskFailures)
      oprot.writeFieldEnd()
    if self.owner is not None:
      oprot.writeFieldBegin('owner', TType.STRUCT, 17)
      self.owner.write(oprot)
      oprot.writeFieldEnd()
    if self.production is not None:
      oprot.writeFieldBegin('production', TType.BOOL, 18)
      oprot.writeBool(self.production)
      oprot.writeFieldEnd()
    if self.constraints is not None:
      oprot.writeFieldBegin('constraints', TType.SET, 20)
      oprot.writeSetBegin(TType.STRUCT, len(self.constraints))
      for iter72 in self.constraints:
        iter72.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.requestedPorts is not None:
      oprot.writeFieldBegin('requestedPorts', TType.SET, 21)
      oprot.writeSetBegin(TType.STRING, len(self.requestedPorts))
      for iter73 in self.requestedPorts:
        oprot.writeString(iter73.encode('utf-8'))
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.taskLinks is not None:
      oprot.writeFieldBegin('taskLinks', TType.MAP, 22)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.taskLinks))
      for kiter74,viter75 in self.taskLinks.items():
        oprot.writeString(kiter74.encode('utf-8'))
        oprot.writeString(viter75.encode('utf-8'))
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.contactEmail is not None:
      oprot.writeFieldBegin('contactEmail', TType.STRING, 23)
      oprot.writeString(self.contactEmail.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.executorConfig is not None:
      oprot.writeFieldBegin('executorConfig', TType.STRUCT, 25)
      self.executorConfig.write(oprot)
      oprot.writeFieldEnd()
    if self.metadata is not None:
      oprot.writeFieldBegin('metadata', TType.SET, 27)
      oprot.writeSetBegin(TType.STRUCT, len(self.metadata))
      for iter76 in self.metadata:
        iter76.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.job is not None:
      oprot.writeFieldBegin('job', TType.STRUCT, 28)
      self.job.write(oprot)
      oprot.writeFieldEnd()
    if self.container is not None:
      oprot.writeFieldBegin('container', TType.STRUCT, 29)
      self.container.write(oprot)
      oprot.writeFieldEnd()
    if self.tier is not None:
      oprot.writeFieldBegin('tier', TType.STRING, 30)
      oprot.writeString(self.tier.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.resources is not None:
      oprot.writeFieldBegin('resources', TType.SET, 32)
      oprot.writeSetBegin(TType.STRUCT, len(self.resources))
      for iter77 in self.resources:
        iter77.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.mesosFetcherUris is not None:
      oprot.writeFieldBegin('mesosFetcherUris', TType.SET, 33)
      oprot.writeSetBegin(TType.STRUCT, len(self.mesosFetcherUris))
      for iter78 in self.mesosFetcherUris:
        iter78.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class ResourceAggregate(object):
  """
  Attributes:
   - numCpus: Number of CPU cores allotted.
   - ramMb: Megabytes of RAM allotted.
   - diskMb: Megabytes of disk space allotted.
   - resources: Aggregated resource values.
  """

  __slots__ = [ 
    'numCpus',
    'ramMb',
    'diskMb',
    'resources',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.DOUBLE, 'numCpus', None, None, ), # 1
    (2, TType.I64, 'ramMb', None, None, ), # 2
    (3, TType.I64, 'diskMb', None, None, ), # 3
    (4, TType.SET, 'resources', (TType.STRUCT,(Resource, Resource.thrift_spec)), None, ), # 4
  )

  def __init__(self, numCpus=None, ramMb=None, diskMb=None, resources=None,):
    self.numCpus = numCpus
    self.ramMb = ramMb
    self.diskMb = diskMb
    self.resources = resources

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          self.numCpus = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.ramMb = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.diskMb = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.SET:
          self.resources = set()
          (_etype82, _size79) = iprot.readSetBegin()
          for _i83 in xrange(_size79):
            _elem84 = Resource()
            _elem84.read(iprot)
            self.resources.add(_elem84)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ResourceAggregate')
    if self.numCpus is not None:
      oprot.writeFieldBegin('numCpus', TType.DOUBLE, 1)
      oprot.writeDouble(self.numCpus)
      oprot.writeFieldEnd()
    if self.ramMb is not None:
      oprot.writeFieldBegin('ramMb', TType.I64, 2)
      oprot.writeI64(self.ramMb)
      oprot.writeFieldEnd()
    if self.diskMb is not None:
      oprot.writeFieldBegin('diskMb', TType.I64, 3)
      oprot.writeI64(self.diskMb)
      oprot.writeFieldEnd()
    if self.resources is not None:
      oprot.writeFieldBegin('resources', TType.SET, 4)
      oprot.writeSetBegin(TType.STRUCT, len(self.resources))
      for iter85 in self.resources:
        iter85.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class JobConfiguration(object):
  """
  Description of an Aurora job. One task will be scheduled for each instance within the job.

  Attributes:
   - key: Key for this job. If not specified name, owner.role, and a reasonable default environment are
  used to construct it server-side.
   - owner: Owner of this job.
   - cronSchedule: If present, the job will be handled as a cron job with this crontab-syntax schedule.
   - cronCollisionPolicy: Collision policy to use when handling overlapping cron runs.  Default is KILL_EXISTING.
   - taskConfig: Task configuration for this job.
   - instanceCount: The number of instances in the job. Generated instance IDs for tasks will be in the range
  [0, instances).
  """

  __slots__ = [ 
    'cronSchedule',
    'cronCollisionPolicy',
    'taskConfig',
    'owner',
    'instanceCount',
    'key',
   ]

  thrift_spec = (
    None, # 0
    None, # 1
    None, # 2
    None, # 3
    (4, TType.STRING, 'cronSchedule', None, None, ), # 4
    (5, TType.I32, 'cronCollisionPolicy', None, None, ), # 5
    (6, TType.STRUCT, 'taskConfig', (TaskConfig, TaskConfig.thrift_spec), None, ), # 6
    (7, TType.STRUCT, 'owner', (Identity, Identity.thrift_spec), None, ), # 7
    (8, TType.I32, 'instanceCount', None, None, ), # 8
    (9, TType.STRUCT, 'key', (JobKey, JobKey.thrift_spec), None, ), # 9
  )

  def __init__(self, key=None, owner=None, cronSchedule=None, cronCollisionPolicy=None, taskConfig=None, instanceCount=None,):
    self.key = key
    self.owner = owner
    self.cronSchedule = cronSchedule
    self.cronCollisionPolicy = cronCollisionPolicy
    self.taskConfig = taskConfig
    self.instanceCount = instanceCount

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 9:
        if ftype == TType.STRUCT:
          self.key = JobKey()
          self.key.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.owner = Identity()
          self.owner.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.cronSchedule = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.cronCollisionPolicy = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.taskConfig = TaskConfig()
          self.taskConfig.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.instanceCount = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JobConfiguration')
    if self.cronSchedule is not None:
      oprot.writeFieldBegin('cronSchedule', TType.STRING, 4)
      oprot.writeString(self.cronSchedule.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.cronCollisionPolicy is not None:
      oprot.writeFieldBegin('cronCollisionPolicy', TType.I32, 5)
      oprot.writeI32(self.cronCollisionPolicy)
      oprot.writeFieldEnd()
    if self.taskConfig is not None:
      oprot.writeFieldBegin('taskConfig', TType.STRUCT, 6)
      self.taskConfig.write(oprot)
      oprot.writeFieldEnd()
    if self.owner is not None:
      oprot.writeFieldBegin('owner', TType.STRUCT, 7)
      self.owner.write(oprot)
      oprot.writeFieldEnd()
    if self.instanceCount is not None:
      oprot.writeFieldBegin('instanceCount', TType.I32, 8)
      oprot.writeI32(self.instanceCount)
      oprot.writeFieldEnd()
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRUCT, 9)
      self.key.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class JobStats(object):
  """
  Attributes:
   - activeTaskCount: Number of tasks in active state for this job.
   - finishedTaskCount: Number of tasks in finished state for this job.
   - failedTaskCount: Number of failed tasks for this job.
   - pendingTaskCount: Number of tasks in pending state for this job.
  """

  __slots__ = [ 
    'activeTaskCount',
    'finishedTaskCount',
    'failedTaskCount',
    'pendingTaskCount',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'activeTaskCount', None, None, ), # 1
    (2, TType.I32, 'finishedTaskCount', None, None, ), # 2
    (3, TType.I32, 'failedTaskCount', None, None, ), # 3
    (4, TType.I32, 'pendingTaskCount', None, None, ), # 4
  )

  def __init__(self, activeTaskCount=None, finishedTaskCount=None, failedTaskCount=None, pendingTaskCount=None,):
    self.activeTaskCount = activeTaskCount
    self.finishedTaskCount = finishedTaskCount
    self.failedTaskCount = failedTaskCount
    self.pendingTaskCount = pendingTaskCount

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.activeTaskCount = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.finishedTaskCount = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.failedTaskCount = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.pendingTaskCount = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JobStats')
    if self.activeTaskCount is not None:
      oprot.writeFieldBegin('activeTaskCount', TType.I32, 1)
      oprot.writeI32(self.activeTaskCount)
      oprot.writeFieldEnd()
    if self.finishedTaskCount is not None:
      oprot.writeFieldBegin('finishedTaskCount', TType.I32, 2)
      oprot.writeI32(self.finishedTaskCount)
      oprot.writeFieldEnd()
    if self.failedTaskCount is not None:
      oprot.writeFieldBegin('failedTaskCount', TType.I32, 3)
      oprot.writeI32(self.failedTaskCount)
      oprot.writeFieldEnd()
    if self.pendingTaskCount is not None:
      oprot.writeFieldBegin('pendingTaskCount', TType.I32, 4)
      oprot.writeI32(self.pendingTaskCount)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class JobSummary(object):
  """
  Attributes:
   - job
   - stats
   - nextCronRunMs: Timestamp of next cron run in ms since epoch, for a cron job
  """

  __slots__ = [ 
    'job',
    'stats',
    'nextCronRunMs',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'job', (JobConfiguration, JobConfiguration.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'stats', (JobStats, JobStats.thrift_spec), None, ), # 2
    (3, TType.I64, 'nextCronRunMs', None, None, ), # 3
  )

  def __init__(self, job=None, stats=None, nextCronRunMs=None,):
    self.job = job
    self.stats = stats
    self.nextCronRunMs = nextCronRunMs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.job = JobConfiguration()
          self.job.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.stats = JobStats()
          self.stats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.nextCronRunMs = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JobSummary')
    if self.job is not None:
      oprot.writeFieldBegin('job', TType.STRUCT, 1)
      self.job.write(oprot)
      oprot.writeFieldEnd()
    if self.stats is not None:
      oprot.writeFieldBegin('stats', TType.STRUCT, 2)
      self.stats.write(oprot)
      oprot.writeFieldEnd()
    if self.nextCronRunMs is not None:
      oprot.writeFieldBegin('nextCronRunMs', TType.I64, 3)
      oprot.writeI64(self.nextCronRunMs)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class Range(object):
  """
  Closed range of integers.

  Attributes:
   - first
   - last
  """

  __slots__ = [ 
    'first',
    'last',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'first', None, None, ), # 1
    (2, TType.I32, 'last', None, None, ), # 2
  )

  def __init__(self, first=None, last=None,):
    self.first = first
    self.last = last

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.first = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.last = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Range')
    if self.first is not None:
      oprot.writeFieldBegin('first', TType.I32, 1)
      oprot.writeI32(self.first)
      oprot.writeFieldEnd()
    if self.last is not None:
      oprot.writeFieldBegin('last', TType.I32, 2)
      oprot.writeI32(self.last)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class ConfigGroup(object):
  """
  Attributes:
   - config
   - instances
  """

  __slots__ = [ 
    'config',
    'instances',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'config', (TaskConfig, TaskConfig.thrift_spec), None, ), # 1
    None, # 2
    (3, TType.SET, 'instances', (TType.STRUCT,(Range, Range.thrift_spec)), None, ), # 3
  )

  def __init__(self, config=None, instances=None,):
    self.config = config
    self.instances = instances

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.config = TaskConfig()
          self.config.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.SET:
          self.instances = set()
          (_etype89, _size86) = iprot.readSetBegin()
          for _i90 in xrange(_size86):
            _elem91 = Range()
            _elem91.read(iprot)
            self.instances.add(_elem91)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ConfigGroup')
    if self.config is not None:
      oprot.writeFieldBegin('config', TType.STRUCT, 1)
      self.config.write(oprot)
      oprot.writeFieldEnd()
    if self.instances is not None:
      oprot.writeFieldBegin('instances', TType.SET, 3)
      oprot.writeSetBegin(TType.STRUCT, len(self.instances))
      for iter92 in self.instances:
        iter92.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class ConfigSummary(object):
  """
  Attributes:
   - key
   - groups
  """

  __slots__ = [ 
    'key',
    'groups',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'key', (JobKey, JobKey.thrift_spec), None, ), # 1
    (2, TType.SET, 'groups', (TType.STRUCT,(ConfigGroup, ConfigGroup.thrift_spec)), None, ), # 2
  )

  def __init__(self, key=None, groups=None,):
    self.key = key
    self.groups = groups

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.key = JobKey()
          self.key.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.SET:
          self.groups = set()
          (_etype96, _size93) = iprot.readSetBegin()
          for _i97 in xrange(_size93):
            _elem98 = ConfigGroup()
            _elem98.read(iprot)
            self.groups.add(_elem98)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ConfigSummary')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRUCT, 1)
      self.key.write(oprot)
      oprot.writeFieldEnd()
    if self.groups is not None:
      oprot.writeFieldBegin('groups', TType.SET, 2)
      oprot.writeSetBegin(TType.STRUCT, len(self.groups))
      for iter99 in self.groups:
        iter99.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class PopulateJobResult(object):
  """
  Attributes:
   - taskConfig
  """

  __slots__ = [ 
    'taskConfig',
   ]

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.STRUCT, 'taskConfig', (TaskConfig, TaskConfig.thrift_spec), None, ), # 2
  )

  def __init__(self, taskConfig=None,):
    self.taskConfig = taskConfig

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.STRUCT:
          self.taskConfig = TaskConfig()
          self.taskConfig.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PopulateJobResult')
    if self.taskConfig is not None:
      oprot.writeFieldBegin('taskConfig', TType.STRUCT, 2)
      self.taskConfig.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class GetQuotaResult(object):
  """
  Attributes:
   - quota: Total allocated resource quota.
   - prodSharedConsumption: Resources consumed by production jobs from a shared resource pool.
   - nonProdSharedConsumption: Resources consumed by non-production jobs from a shared resource pool.
   - prodDedicatedConsumption: Resources consumed by production jobs from a dedicated resource pool.
   - nonProdDedicatedConsumption: Resources consumed by non-production jobs from a dedicated resource pool.
  """

  __slots__ = [ 
    'quota',
    'prodSharedConsumption',
    'nonProdSharedConsumption',
    'prodDedicatedConsumption',
    'nonProdDedicatedConsumption',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'quota', (ResourceAggregate, ResourceAggregate.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'prodSharedConsumption', (ResourceAggregate, ResourceAggregate.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'nonProdSharedConsumption', (ResourceAggregate, ResourceAggregate.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'prodDedicatedConsumption', (ResourceAggregate, ResourceAggregate.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'nonProdDedicatedConsumption', (ResourceAggregate, ResourceAggregate.thrift_spec), None, ), # 5
  )

  def __init__(self, quota=None, prodSharedConsumption=None, nonProdSharedConsumption=None, prodDedicatedConsumption=None, nonProdDedicatedConsumption=None,):
    self.quota = quota
    self.prodSharedConsumption = prodSharedConsumption
    self.nonProdSharedConsumption = nonProdSharedConsumption
    self.prodDedicatedConsumption = prodDedicatedConsumption
    self.nonProdDedicatedConsumption = nonProdDedicatedConsumption

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.quota = ResourceAggregate()
          self.quota.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.prodSharedConsumption = ResourceAggregate()
          self.prodSharedConsumption.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.nonProdSharedConsumption = ResourceAggregate()
          self.nonProdSharedConsumption.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.prodDedicatedConsumption = ResourceAggregate()
          self.prodDedicatedConsumption.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.nonProdDedicatedConsumption = ResourceAggregate()
          self.nonProdDedicatedConsumption.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetQuotaResult')
    if self.quota is not None:
      oprot.writeFieldBegin('quota', TType.STRUCT, 1)
      self.quota.write(oprot)
      oprot.writeFieldEnd()
    if self.prodSharedConsumption is not None:
      oprot.writeFieldBegin('prodSharedConsumption', TType.STRUCT, 2)
      self.prodSharedConsumption.write(oprot)
      oprot.writeFieldEnd()
    if self.nonProdSharedConsumption is not None:
      oprot.writeFieldBegin('nonProdSharedConsumption', TType.STRUCT, 3)
      self.nonProdSharedConsumption.write(oprot)
      oprot.writeFieldEnd()
    if self.prodDedicatedConsumption is not None:
      oprot.writeFieldBegin('prodDedicatedConsumption', TType.STRUCT, 4)
      self.prodDedicatedConsumption.write(oprot)
      oprot.writeFieldEnd()
    if self.nonProdDedicatedConsumption is not None:
      oprot.writeFieldBegin('nonProdDedicatedConsumption', TType.STRUCT, 5)
      self.nonProdDedicatedConsumption.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class TaskEvent(object):
  """
  Event marking a state transition within a task's lifecycle.

  Attributes:
   - timestamp: Epoch timestamp in milliseconds.
   - status: New status of the task.
   - message: Audit message that explains why a transition occurred.
   - scheduler: Hostname of the scheduler machine that performed the event.
  """

  __slots__ = [ 
    'timestamp',
    'status',
    'message',
    'scheduler',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'timestamp', None, None, ), # 1
    (2, TType.I32, 'status', None, None, ), # 2
    (3, TType.STRING, 'message', None, None, ), # 3
    (4, TType.STRING, 'scheduler', None, None, ), # 4
  )

  def __init__(self, timestamp=None, status=None, message=None, scheduler=None,):
    self.timestamp = timestamp
    self.status = status
    self.message = message
    self.scheduler = scheduler

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.status = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.message = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.scheduler = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TaskEvent')
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 1)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.I32, 2)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 3)
      oprot.writeString(self.message.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.scheduler is not None:
      oprot.writeFieldBegin('scheduler', TType.STRING, 4)
      oprot.writeString(self.scheduler.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class AssignedTask(object):
  """
  A task assignment that is provided to an executor.

  Attributes:
   - taskId: The mesos task ID for this task.  Guaranteed to be globally unique
   - slaveId: The mesos slave ID that this task has been assigned to.
  This will not be populated for a PENDING task.
   - slaveHost: The name of the machine that this task has been assigned to.
  This will not be populated for a PENDING task.
   - task: Information about how to run this task.
   - assignedPorts: Ports reserved on the machine while this task is running.
   - instanceId: The instance ID assigned to this task. Instance IDs must be unique and contiguous within a
  job, and will be in the range [0, N-1] (inclusive) for a job that has N instances.
  """

  __slots__ = [ 
    'taskId',
    'slaveId',
    'slaveHost',
    'task',
    'assignedPorts',
    'instanceId',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'taskId', None, None, ), # 1
    (2, TType.STRING, 'slaveId', None, None, ), # 2
    (3, TType.STRING, 'slaveHost', None, None, ), # 3
    (4, TType.STRUCT, 'task', (TaskConfig, TaskConfig.thrift_spec), None, ), # 4
    (5, TType.MAP, 'assignedPorts', (TType.STRING,None,TType.I32,None), None, ), # 5
    (6, TType.I32, 'instanceId', None, None, ), # 6
  )

  def __init__(self, taskId=None, slaveId=None, slaveHost=None, task=None, assignedPorts=None, instanceId=None,):
    self.taskId = taskId
    self.slaveId = slaveId
    self.slaveHost = slaveHost
    self.task = task
    self.assignedPorts = assignedPorts
    self.instanceId = instanceId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.taskId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.slaveId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.slaveHost = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.task = TaskConfig()
          self.task.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.assignedPorts = {}
          (_ktype101, _vtype102, _size100 ) = iprot.readMapBegin()
          for _i104 in xrange(_size100):
            _key105 = iprot.readString().decode('utf-8')
            _val106 = iprot.readI32()
            self.assignedPorts[_key105] = _val106
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.instanceId = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AssignedTask')
    if self.taskId is not None:
      oprot.writeFieldBegin('taskId', TType.STRING, 1)
      oprot.writeString(self.taskId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.slaveId is not None:
      oprot.writeFieldBegin('slaveId', TType.STRING, 2)
      oprot.writeString(self.slaveId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.slaveHost is not None:
      oprot.writeFieldBegin('slaveHost', TType.STRING, 3)
      oprot.writeString(self.slaveHost.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.task is not None:
      oprot.writeFieldBegin('task', TType.STRUCT, 4)
      self.task.write(oprot)
      oprot.writeFieldEnd()
    if self.assignedPorts is not None:
      oprot.writeFieldBegin('assignedPorts', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.assignedPorts))
      for kiter107,viter108 in self.assignedPorts.items():
        oprot.writeString(kiter107.encode('utf-8'))
        oprot.writeI32(viter108)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.instanceId is not None:
      oprot.writeFieldBegin('instanceId', TType.I32, 6)
      oprot.writeI32(self.instanceId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class ScheduledTask(object):
  """
  A task that has been scheduled.

  Attributes:
   - assignedTask: The task that was scheduled.
   - status: The current status of this task.
   - failureCount: The number of failures that this task has accumulated over the multi-generational history of
  this task.
   - taskEvents: State change history for this task.
   - ancestorId: The task ID of the previous generation of this task.  When a task is automatically rescheduled,
  a copy of the task is created and ancestor ID of the previous task's task ID.
  """

  __slots__ = [ 
    'assignedTask',
    'status',
    'failureCount',
    'taskEvents',
    'ancestorId',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'assignedTask', (AssignedTask, AssignedTask.thrift_spec), None, ), # 1
    (2, TType.I32, 'status', None, None, ), # 2
    (3, TType.I32, 'failureCount', None, None, ), # 3
    (4, TType.LIST, 'taskEvents', (TType.STRUCT,(TaskEvent, TaskEvent.thrift_spec)), None, ), # 4
    (5, TType.STRING, 'ancestorId', None, None, ), # 5
  )

  def __init__(self, assignedTask=None, status=None, failureCount=None, taskEvents=None, ancestorId=None,):
    self.assignedTask = assignedTask
    self.status = status
    self.failureCount = failureCount
    self.taskEvents = taskEvents
    self.ancestorId = ancestorId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.assignedTask = AssignedTask()
          self.assignedTask.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.status = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.failureCount = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.taskEvents = []
          (_etype112, _size109) = iprot.readListBegin()
          for _i113 in xrange(_size109):
            _elem114 = TaskEvent()
            _elem114.read(iprot)
            self.taskEvents.append(_elem114)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.ancestorId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ScheduledTask')
    if self.assignedTask is not None:
      oprot.writeFieldBegin('assignedTask', TType.STRUCT, 1)
      self.assignedTask.write(oprot)
      oprot.writeFieldEnd()
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.I32, 2)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    if self.failureCount is not None:
      oprot.writeFieldBegin('failureCount', TType.I32, 3)
      oprot.writeI32(self.failureCount)
      oprot.writeFieldEnd()
    if self.taskEvents is not None:
      oprot.writeFieldBegin('taskEvents', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.taskEvents))
      for iter115 in self.taskEvents:
        iter115.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ancestorId is not None:
      oprot.writeFieldBegin('ancestorId', TType.STRING, 5)
      oprot.writeString(self.ancestorId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class ScheduleStatusResult(object):
  """
  Attributes:
   - tasks
  """

  __slots__ = [ 
    'tasks',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'tasks', (TType.STRUCT,(ScheduledTask, ScheduledTask.thrift_spec)), None, ), # 1
  )

  def __init__(self, tasks=None,):
    self.tasks = tasks

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.tasks = []
          (_etype119, _size116) = iprot.readListBegin()
          for _i120 in xrange(_size116):
            _elem121 = ScheduledTask()
            _elem121.read(iprot)
            self.tasks.append(_elem121)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ScheduleStatusResult')
    if self.tasks is not None:
      oprot.writeFieldBegin('tasks', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.tasks))
      for iter122 in self.tasks:
        iter122.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class GetJobsResult(object):
  """
  Attributes:
   - configs
  """

  __slots__ = [ 
    'configs',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'configs', (TType.STRUCT,(JobConfiguration, JobConfiguration.thrift_spec)), None, ), # 1
  )

  def __init__(self, configs=None,):
    self.configs = configs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.configs = set()
          (_etype126, _size123) = iprot.readSetBegin()
          for _i127 in xrange(_size123):
            _elem128 = JobConfiguration()
            _elem128.read(iprot)
            self.configs.add(_elem128)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetJobsResult')
    if self.configs is not None:
      oprot.writeFieldBegin('configs', TType.SET, 1)
      oprot.writeSetBegin(TType.STRUCT, len(self.configs))
      for iter129 in self.configs:
        iter129.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class TaskQuery(object):
  """
  Contains a set of restrictions on matching tasks where all restrictions must be met
  (terms are AND'ed together).

  Attributes:
   - role
   - environment
   - jobName
   - taskIds
   - statuses
   - instanceIds
   - slaveHosts
   - jobKeys
   - offset
   - limit
  """

  __slots__ = [ 
    'jobName',
    'taskIds',
    'statuses',
    'instanceIds',
    'environment',
    'slaveHosts',
    'jobKeys',
    'offset',
    'limit',
    'role',
   ]

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.STRING, 'jobName', None, None, ), # 2
    None, # 3
    (4, TType.SET, 'taskIds', (TType.STRING,None), None, ), # 4
    (5, TType.SET, 'statuses', (TType.I32,None), None, ), # 5
    None, # 6
    (7, TType.SET, 'instanceIds', (TType.I32,None), None, ), # 7
    None, # 8
    (9, TType.STRING, 'environment', None, None, ), # 9
    (10, TType.SET, 'slaveHosts', (TType.STRING,None), None, ), # 10
    (11, TType.SET, 'jobKeys', (TType.STRUCT,(JobKey, JobKey.thrift_spec)), None, ), # 11
    (12, TType.I32, 'offset', None, None, ), # 12
    (13, TType.I32, 'limit', None, None, ), # 13
    (14, TType.STRING, 'role', None, None, ), # 14
  )

  def __init__(self, role=None, environment=None, jobName=None, taskIds=None, statuses=None, instanceIds=None, slaveHosts=None, jobKeys=None, offset=None, limit=None,):
    self.role = role
    self.environment = environment
    self.jobName = jobName
    self.taskIds = taskIds
    self.statuses = statuses
    self.instanceIds = instanceIds
    self.slaveHosts = slaveHosts
    self.jobKeys = jobKeys
    self.offset = offset
    self.limit = limit

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 14:
        if ftype == TType.STRING:
          self.role = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.environment = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.jobName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.SET:
          self.taskIds = set()
          (_etype133, _size130) = iprot.readSetBegin()
          for _i134 in xrange(_size130):
            _elem135 = iprot.readString().decode('utf-8')
            self.taskIds.add(_elem135)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.SET:
          self.statuses = set()
          (_etype139, _size136) = iprot.readSetBegin()
          for _i140 in xrange(_size136):
            _elem141 = iprot.readI32()
            self.statuses.add(_elem141)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.SET:
          self.instanceIds = set()
          (_etype145, _size142) = iprot.readSetBegin()
          for _i146 in xrange(_size142):
            _elem147 = iprot.readI32()
            self.instanceIds.add(_elem147)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.SET:
          self.slaveHosts = set()
          (_etype151, _size148) = iprot.readSetBegin()
          for _i152 in xrange(_size148):
            _elem153 = iprot.readString().decode('utf-8')
            self.slaveHosts.add(_elem153)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.SET:
          self.jobKeys = set()
          (_etype157, _size154) = iprot.readSetBegin()
          for _i158 in xrange(_size154):
            _elem159 = JobKey()
            _elem159.read(iprot)
            self.jobKeys.add(_elem159)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I32:
          self.offset = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.I32:
          self.limit = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TaskQuery')
    if self.jobName is not None:
      oprot.writeFieldBegin('jobName', TType.STRING, 2)
      oprot.writeString(self.jobName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.taskIds is not None:
      oprot.writeFieldBegin('taskIds', TType.SET, 4)
      oprot.writeSetBegin(TType.STRING, len(self.taskIds))
      for iter160 in self.taskIds:
        oprot.writeString(iter160.encode('utf-8'))
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.statuses is not None:
      oprot.writeFieldBegin('statuses', TType.SET, 5)
      oprot.writeSetBegin(TType.I32, len(self.statuses))
      for iter161 in self.statuses:
        oprot.writeI32(iter161)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.instanceIds is not None:
      oprot.writeFieldBegin('instanceIds', TType.SET, 7)
      oprot.writeSetBegin(TType.I32, len(self.instanceIds))
      for iter162 in self.instanceIds:
        oprot.writeI32(iter162)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 9)
      oprot.writeString(self.environment.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.slaveHosts is not None:
      oprot.writeFieldBegin('slaveHosts', TType.SET, 10)
      oprot.writeSetBegin(TType.STRING, len(self.slaveHosts))
      for iter163 in self.slaveHosts:
        oprot.writeString(iter163.encode('utf-8'))
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.jobKeys is not None:
      oprot.writeFieldBegin('jobKeys', TType.SET, 11)
      oprot.writeSetBegin(TType.STRUCT, len(self.jobKeys))
      for iter164 in self.jobKeys:
        iter164.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.offset is not None:
      oprot.writeFieldBegin('offset', TType.I32, 12)
      oprot.writeI32(self.offset)
      oprot.writeFieldEnd()
    if self.limit is not None:
      oprot.writeFieldBegin('limit', TType.I32, 13)
      oprot.writeI32(self.limit)
      oprot.writeFieldEnd()
    if self.role is not None:
      oprot.writeFieldBegin('role', TType.STRING, 14)
      oprot.writeString(self.role.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class HostStatus(object):
  """
  Attributes:
   - host
   - mode
  """

  __slots__ = [ 
    'host',
    'mode',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'host', None, None, ), # 1
    (2, TType.I32, 'mode', None, None, ), # 2
  )

  def __init__(self, host=None, mode=None,):
    self.host = host
    self.mode = mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.host = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.mode = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('HostStatus')
    if self.host is not None:
      oprot.writeFieldBegin('host', TType.STRING, 1)
      oprot.writeString(self.host.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.mode is not None:
      oprot.writeFieldBegin('mode', TType.I32, 2)
      oprot.writeI32(self.mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class RoleSummary(object):
  """
  Attributes:
   - role
   - jobCount
   - cronJobCount
  """

  __slots__ = [ 
    'role',
    'jobCount',
    'cronJobCount',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'role', None, None, ), # 1
    (2, TType.I32, 'jobCount', None, None, ), # 2
    (3, TType.I32, 'cronJobCount', None, None, ), # 3
  )

  def __init__(self, role=None, jobCount=None, cronJobCount=None,):
    self.role = role
    self.jobCount = jobCount
    self.cronJobCount = cronJobCount

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.role = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.jobCount = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.cronJobCount = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RoleSummary')
    if self.role is not None:
      oprot.writeFieldBegin('role', TType.STRING, 1)
      oprot.writeString(self.role.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.jobCount is not None:
      oprot.writeFieldBegin('jobCount', TType.I32, 2)
      oprot.writeI32(self.jobCount)
      oprot.writeFieldEnd()
    if self.cronJobCount is not None:
      oprot.writeFieldBegin('cronJobCount', TType.I32, 3)
      oprot.writeI32(self.cronJobCount)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class Hosts(object):
  """
  Attributes:
   - hostNames
  """

  __slots__ = [ 
    'hostNames',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'hostNames', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, hostNames=None,):
    self.hostNames = hostNames

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.hostNames = set()
          (_etype168, _size165) = iprot.readSetBegin()
          for _i169 in xrange(_size165):
            _elem170 = iprot.readString().decode('utf-8')
            self.hostNames.add(_elem170)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Hosts')
    if self.hostNames is not None:
      oprot.writeFieldBegin('hostNames', TType.SET, 1)
      oprot.writeSetBegin(TType.STRING, len(self.hostNames))
      for iter171 in self.hostNames:
        oprot.writeString(iter171.encode('utf-8'))
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class PendingReason(object):
  """
  Attributes:
   - taskId
   - reason
  """

  __slots__ = [ 
    'taskId',
    'reason',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'taskId', None, None, ), # 1
    (2, TType.STRING, 'reason', None, None, ), # 2
  )

  def __init__(self, taskId=None, reason=None,):
    self.taskId = taskId
    self.reason = reason

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.taskId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.reason = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PendingReason')
    if self.taskId is not None:
      oprot.writeFieldBegin('taskId', TType.STRING, 1)
      oprot.writeString(self.taskId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.reason is not None:
      oprot.writeFieldBegin('reason', TType.STRING, 2)
      oprot.writeString(self.reason.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class JobUpdateKey(object):
  """
  Job update key.

  Attributes:
   - job: Job being updated
   - id: Update ID.
  """

  __slots__ = [ 
    'job',
    'id',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'job', (JobKey, JobKey.thrift_spec), None, ), # 1
    (2, TType.STRING, 'id', None, None, ), # 2
  )

  def __init__(self, job=None, id=None,):
    self.job = job
    self.id = id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.job = JobKey()
          self.job.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.id = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JobUpdateKey')
    if self.job is not None:
      oprot.writeFieldBegin('job', TType.STRUCT, 1)
      self.job.write(oprot)
      oprot.writeFieldEnd()
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.STRING, 2)
      oprot.writeString(self.id.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class JobUpdateSettings(object):
  """
  Job update thresholds and limits.

  Attributes:
   - updateGroupSize: Max number of instances being updated at any given moment.
   - maxPerInstanceFailures: Max number of instance failures to tolerate before marking instance as FAILED.
   - maxFailedInstances: Max number of FAILED instances to tolerate before terminating the update.
   - minWaitInInstanceRunningMs: Min time to watch a RUNNING instance.
   - rollbackOnFailure: If true, enables failed update rollback.
   - updateOnlyTheseInstances: Instance IDs to act on. All instances will be affected if this is not set.
   - waitForBatchCompletion: If true, use updateGroupSize as strict batching boundaries, and avoid proceeding to another
  batch until the preceding batch finishes updating.
   - blockIfNoPulsesAfterMs: If set, requires external calls to pulseJobUpdate RPC within the specified rate for the
  update to make progress. If no pulses received within specified interval the update will
  block. A blocked update is unable to continue but retains its current status. It may only get
  unblocked by a fresh pulseJobUpdate call.
  """

  __slots__ = [ 
    'updateGroupSize',
    'maxPerInstanceFailures',
    'maxFailedInstances',
    'minWaitInInstanceRunningMs',
    'rollbackOnFailure',
    'updateOnlyTheseInstances',
    'waitForBatchCompletion',
    'blockIfNoPulsesAfterMs',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'updateGroupSize', None, None, ), # 1
    (2, TType.I32, 'maxPerInstanceFailures', None, None, ), # 2
    (3, TType.I32, 'maxFailedInstances', None, None, ), # 3
    None, # 4
    (5, TType.I32, 'minWaitInInstanceRunningMs', None, None, ), # 5
    (6, TType.BOOL, 'rollbackOnFailure', None, None, ), # 6
    (7, TType.SET, 'updateOnlyTheseInstances', (TType.STRUCT,(Range, Range.thrift_spec)), None, ), # 7
    (8, TType.BOOL, 'waitForBatchCompletion', None, None, ), # 8
    (9, TType.I32, 'blockIfNoPulsesAfterMs', None, None, ), # 9
  )

  def __init__(self, updateGroupSize=None, maxPerInstanceFailures=None, maxFailedInstances=None, minWaitInInstanceRunningMs=None, rollbackOnFailure=None, updateOnlyTheseInstances=None, waitForBatchCompletion=None, blockIfNoPulsesAfterMs=None,):
    self.updateGroupSize = updateGroupSize
    self.maxPerInstanceFailures = maxPerInstanceFailures
    self.maxFailedInstances = maxFailedInstances
    self.minWaitInInstanceRunningMs = minWaitInInstanceRunningMs
    self.rollbackOnFailure = rollbackOnFailure
    self.updateOnlyTheseInstances = updateOnlyTheseInstances
    self.waitForBatchCompletion = waitForBatchCompletion
    self.blockIfNoPulsesAfterMs = blockIfNoPulsesAfterMs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.updateGroupSize = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.maxPerInstanceFailures = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.maxFailedInstances = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.minWaitInInstanceRunningMs = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.rollbackOnFailure = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.SET:
          self.updateOnlyTheseInstances = set()
          (_etype175, _size172) = iprot.readSetBegin()
          for _i176 in xrange(_size172):
            _elem177 = Range()
            _elem177.read(iprot)
            self.updateOnlyTheseInstances.add(_elem177)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.waitForBatchCompletion = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I32:
          self.blockIfNoPulsesAfterMs = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JobUpdateSettings')
    if self.updateGroupSize is not None:
      oprot.writeFieldBegin('updateGroupSize', TType.I32, 1)
      oprot.writeI32(self.updateGroupSize)
      oprot.writeFieldEnd()
    if self.maxPerInstanceFailures is not None:
      oprot.writeFieldBegin('maxPerInstanceFailures', TType.I32, 2)
      oprot.writeI32(self.maxPerInstanceFailures)
      oprot.writeFieldEnd()
    if self.maxFailedInstances is not None:
      oprot.writeFieldBegin('maxFailedInstances', TType.I32, 3)
      oprot.writeI32(self.maxFailedInstances)
      oprot.writeFieldEnd()
    if self.minWaitInInstanceRunningMs is not None:
      oprot.writeFieldBegin('minWaitInInstanceRunningMs', TType.I32, 5)
      oprot.writeI32(self.minWaitInInstanceRunningMs)
      oprot.writeFieldEnd()
    if self.rollbackOnFailure is not None:
      oprot.writeFieldBegin('rollbackOnFailure', TType.BOOL, 6)
      oprot.writeBool(self.rollbackOnFailure)
      oprot.writeFieldEnd()
    if self.updateOnlyTheseInstances is not None:
      oprot.writeFieldBegin('updateOnlyTheseInstances', TType.SET, 7)
      oprot.writeSetBegin(TType.STRUCT, len(self.updateOnlyTheseInstances))
      for iter178 in self.updateOnlyTheseInstances:
        iter178.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.waitForBatchCompletion is not None:
      oprot.writeFieldBegin('waitForBatchCompletion', TType.BOOL, 8)
      oprot.writeBool(self.waitForBatchCompletion)
      oprot.writeFieldEnd()
    if self.blockIfNoPulsesAfterMs is not None:
      oprot.writeFieldBegin('blockIfNoPulsesAfterMs', TType.I32, 9)
      oprot.writeI32(self.blockIfNoPulsesAfterMs)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class JobUpdateEvent(object):
  """
  Event marking a state transition in job update lifecycle.

  Attributes:
   - status: Update status.
   - timestampMs: Epoch timestamp in milliseconds.
   - user: User who performed this event (if user-initiated).
   - message: Message from the user (for user-initiated transitions) or the scheduler about why the state was
  changed.
  """

  __slots__ = [ 
    'status',
    'timestampMs',
    'user',
    'message',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'status', None, None, ), # 1
    (2, TType.I64, 'timestampMs', None, None, ), # 2
    (3, TType.STRING, 'user', None, None, ), # 3
    (4, TType.STRING, 'message', None, None, ), # 4
  )

  def __init__(self, status=None, timestampMs=None, user=None, message=None,):
    self.status = status
    self.timestampMs = timestampMs
    self.user = user
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.status = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestampMs = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.user = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.message = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JobUpdateEvent')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.I32, 1)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    if self.timestampMs is not None:
      oprot.writeFieldBegin('timestampMs', TType.I64, 2)
      oprot.writeI64(self.timestampMs)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 3)
      oprot.writeString(self.user.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 4)
      oprot.writeString(self.message.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class JobInstanceUpdateEvent(object):
  """
  Event marking a state transition in job instance update lifecycle.

  Attributes:
   - instanceId: Job instance ID.
   - timestampMs: Epoch timestamp in milliseconds.
   - action: Job update action taken on the instance.
  """

  __slots__ = [ 
    'instanceId',
    'timestampMs',
    'action',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'instanceId', None, None, ), # 1
    (2, TType.I64, 'timestampMs', None, None, ), # 2
    (3, TType.I32, 'action', None, None, ), # 3
  )

  def __init__(self, instanceId=None, timestampMs=None, action=None,):
    self.instanceId = instanceId
    self.timestampMs = timestampMs
    self.action = action

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.instanceId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestampMs = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.action = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JobInstanceUpdateEvent')
    if self.instanceId is not None:
      oprot.writeFieldBegin('instanceId', TType.I32, 1)
      oprot.writeI32(self.instanceId)
      oprot.writeFieldEnd()
    if self.timestampMs is not None:
      oprot.writeFieldBegin('timestampMs', TType.I64, 2)
      oprot.writeI64(self.timestampMs)
      oprot.writeFieldEnd()
    if self.action is not None:
      oprot.writeFieldBegin('action', TType.I32, 3)
      oprot.writeI32(self.action)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class InstanceTaskConfig(object):
  """
  Maps instance IDs to TaskConfigs it.

  Attributes:
   - task: A TaskConfig associated with instances.
   - instances: Instances associated with the TaskConfig.
  """

  __slots__ = [ 
    'task',
    'instances',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'task', (TaskConfig, TaskConfig.thrift_spec), None, ), # 1
    (2, TType.SET, 'instances', (TType.STRUCT,(Range, Range.thrift_spec)), None, ), # 2
  )

  def __init__(self, task=None, instances=None,):
    self.task = task
    self.instances = instances

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.task = TaskConfig()
          self.task.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.SET:
          self.instances = set()
          (_etype182, _size179) = iprot.readSetBegin()
          for _i183 in xrange(_size179):
            _elem184 = Range()
            _elem184.read(iprot)
            self.instances.add(_elem184)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InstanceTaskConfig')
    if self.task is not None:
      oprot.writeFieldBegin('task', TType.STRUCT, 1)
      self.task.write(oprot)
      oprot.writeFieldEnd()
    if self.instances is not None:
      oprot.writeFieldBegin('instances', TType.SET, 2)
      oprot.writeSetBegin(TType.STRUCT, len(self.instances))
      for iter185 in self.instances:
        iter185.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class JobUpdateState(object):
  """
  Current job update state including status and created/modified timestamps.

  Attributes:
   - status: Current status of the update.
   - createdTimestampMs: Created timestamp in milliseconds.
   - lastModifiedTimestampMs: Last modified timestamp in milliseconds.
  """

  __slots__ = [ 
    'status',
    'createdTimestampMs',
    'lastModifiedTimestampMs',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'status', None, None, ), # 1
    (2, TType.I64, 'createdTimestampMs', None, None, ), # 2
    (3, TType.I64, 'lastModifiedTimestampMs', None, None, ), # 3
  )

  def __init__(self, status=None, createdTimestampMs=None, lastModifiedTimestampMs=None,):
    self.status = status
    self.createdTimestampMs = createdTimestampMs
    self.lastModifiedTimestampMs = lastModifiedTimestampMs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.status = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.createdTimestampMs = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.lastModifiedTimestampMs = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JobUpdateState')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.I32, 1)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    if self.createdTimestampMs is not None:
      oprot.writeFieldBegin('createdTimestampMs', TType.I64, 2)
      oprot.writeI64(self.createdTimestampMs)
      oprot.writeFieldEnd()
    if self.lastModifiedTimestampMs is not None:
      oprot.writeFieldBegin('lastModifiedTimestampMs', TType.I64, 3)
      oprot.writeI64(self.lastModifiedTimestampMs)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class JobUpdateSummary(object):
  """
  Summary of the job update including job key, user and current state.

  Attributes:
   - key: Unique identifier for the update.
   - user: User initiated an update.
   - state: Current job update state.
   - metadata: Update metadata supplied by the client.
  """

  __slots__ = [ 
    'user',
    'state',
    'key',
    'metadata',
   ]

  thrift_spec = (
    None, # 0
    None, # 1
    None, # 2
    (3, TType.STRING, 'user', None, None, ), # 3
    (4, TType.STRUCT, 'state', (JobUpdateState, JobUpdateState.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'key', (JobUpdateKey, JobUpdateKey.thrift_spec), None, ), # 5
    (6, TType.SET, 'metadata', (TType.STRUCT,(Metadata, Metadata.thrift_spec)), None, ), # 6
  )

  def __init__(self, key=None, user=None, state=None, metadata=None,):
    self.key = key
    self.user = user
    self.state = state
    self.metadata = metadata

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 5:
        if ftype == TType.STRUCT:
          self.key = JobUpdateKey()
          self.key.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.user = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.state = JobUpdateState()
          self.state.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.SET:
          self.metadata = set()
          (_etype189, _size186) = iprot.readSetBegin()
          for _i190 in xrange(_size186):
            _elem191 = Metadata()
            _elem191.read(iprot)
            self.metadata.add(_elem191)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JobUpdateSummary')
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 3)
      oprot.writeString(self.user.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.state is not None:
      oprot.writeFieldBegin('state', TType.STRUCT, 4)
      self.state.write(oprot)
      oprot.writeFieldEnd()
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRUCT, 5)
      self.key.write(oprot)
      oprot.writeFieldEnd()
    if self.metadata is not None:
      oprot.writeFieldBegin('metadata', TType.SET, 6)
      oprot.writeSetBegin(TType.STRUCT, len(self.metadata))
      for iter192 in self.metadata:
        iter192.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class JobUpdateInstructions(object):
  """
  Update configuration and setting details.

  Attributes:
   - initialState: Actual InstanceId -> TaskConfig mapping when the update was requested.
   - desiredState: Desired configuration when the update completes.
   - settings: Update specific settings.
  """

  __slots__ = [ 
    'initialState',
    'desiredState',
    'settings',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'initialState', (TType.STRUCT,(InstanceTaskConfig, InstanceTaskConfig.thrift_spec)), None, ), # 1
    (2, TType.STRUCT, 'desiredState', (InstanceTaskConfig, InstanceTaskConfig.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'settings', (JobUpdateSettings, JobUpdateSettings.thrift_spec), None, ), # 3
  )

  def __init__(self, initialState=None, desiredState=None, settings=None,):
    self.initialState = initialState
    self.desiredState = desiredState
    self.settings = settings

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.initialState = set()
          (_etype196, _size193) = iprot.readSetBegin()
          for _i197 in xrange(_size193):
            _elem198 = InstanceTaskConfig()
            _elem198.read(iprot)
            self.initialState.add(_elem198)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.desiredState = InstanceTaskConfig()
          self.desiredState.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.settings = JobUpdateSettings()
          self.settings.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JobUpdateInstructions')
    if self.initialState is not None:
      oprot.writeFieldBegin('initialState', TType.SET, 1)
      oprot.writeSetBegin(TType.STRUCT, len(self.initialState))
      for iter199 in self.initialState:
        iter199.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.desiredState is not None:
      oprot.writeFieldBegin('desiredState', TType.STRUCT, 2)
      self.desiredState.write(oprot)
      oprot.writeFieldEnd()
    if self.settings is not None:
      oprot.writeFieldBegin('settings', TType.STRUCT, 3)
      self.settings.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class JobUpdate(object):
  """
  Full definition of the job update.

  Attributes:
   - summary: Update summary.
   - instructions: Update configuration.
  """

  __slots__ = [ 
    'summary',
    'instructions',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'summary', (JobUpdateSummary, JobUpdateSummary.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'instructions', (JobUpdateInstructions, JobUpdateInstructions.thrift_spec), None, ), # 2
  )

  def __init__(self, summary=None, instructions=None,):
    self.summary = summary
    self.instructions = instructions

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.summary = JobUpdateSummary()
          self.summary.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.instructions = JobUpdateInstructions()
          self.instructions.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JobUpdate')
    if self.summary is not None:
      oprot.writeFieldBegin('summary', TType.STRUCT, 1)
      self.summary.write(oprot)
      oprot.writeFieldEnd()
    if self.instructions is not None:
      oprot.writeFieldBegin('instructions', TType.STRUCT, 2)
      self.instructions.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class JobUpdateDetails(object):
  """
  Attributes:
   - update: Update definition.
   - updateEvents: History for this update.
   - instanceEvents: History for the individual instances updated.
  """

  __slots__ = [ 
    'update',
    'updateEvents',
    'instanceEvents',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'update', (JobUpdate, JobUpdate.thrift_spec), None, ), # 1
    (2, TType.LIST, 'updateEvents', (TType.STRUCT,(JobUpdateEvent, JobUpdateEvent.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'instanceEvents', (TType.STRUCT,(JobInstanceUpdateEvent, JobInstanceUpdateEvent.thrift_spec)), None, ), # 3
  )

  def __init__(self, update=None, updateEvents=None, instanceEvents=None,):
    self.update = update
    self.updateEvents = updateEvents
    self.instanceEvents = instanceEvents

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.update = JobUpdate()
          self.update.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.updateEvents = []
          (_etype203, _size200) = iprot.readListBegin()
          for _i204 in xrange(_size200):
            _elem205 = JobUpdateEvent()
            _elem205.read(iprot)
            self.updateEvents.append(_elem205)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.instanceEvents = []
          (_etype209, _size206) = iprot.readListBegin()
          for _i210 in xrange(_size206):
            _elem211 = JobInstanceUpdateEvent()
            _elem211.read(iprot)
            self.instanceEvents.append(_elem211)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JobUpdateDetails')
    if self.update is not None:
      oprot.writeFieldBegin('update', TType.STRUCT, 1)
      self.update.write(oprot)
      oprot.writeFieldEnd()
    if self.updateEvents is not None:
      oprot.writeFieldBegin('updateEvents', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.updateEvents))
      for iter212 in self.updateEvents:
        iter212.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.instanceEvents is not None:
      oprot.writeFieldBegin('instanceEvents', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.instanceEvents))
      for iter213 in self.instanceEvents:
        iter213.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class JobUpdateRequest(object):
  """
  A request to update the following instances of an existing job. Used by startUpdate.

  Attributes:
   - taskConfig: Desired TaskConfig to apply.
   - instanceCount: Desired number of instances of the task config.
   - settings: Update settings and limits.
   - metadata: Update metadata supplied by the client issuing the JobUpdateRequest.
  """

  __slots__ = [ 
    'taskConfig',
    'instanceCount',
    'settings',
    'metadata',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'taskConfig', (TaskConfig, TaskConfig.thrift_spec), None, ), # 1
    (2, TType.I32, 'instanceCount', None, None, ), # 2
    (3, TType.STRUCT, 'settings', (JobUpdateSettings, JobUpdateSettings.thrift_spec), None, ), # 3
    (4, TType.SET, 'metadata', (TType.STRUCT,(Metadata, Metadata.thrift_spec)), None, ), # 4
  )

  def __init__(self, taskConfig=None, instanceCount=None, settings=None, metadata=None,):
    self.taskConfig = taskConfig
    self.instanceCount = instanceCount
    self.settings = settings
    self.metadata = metadata

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.taskConfig = TaskConfig()
          self.taskConfig.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.instanceCount = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.settings = JobUpdateSettings()
          self.settings.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.SET:
          self.metadata = set()
          (_etype217, _size214) = iprot.readSetBegin()
          for _i218 in xrange(_size214):
            _elem219 = Metadata()
            _elem219.read(iprot)
            self.metadata.add(_elem219)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JobUpdateRequest')
    if self.taskConfig is not None:
      oprot.writeFieldBegin('taskConfig', TType.STRUCT, 1)
      self.taskConfig.write(oprot)
      oprot.writeFieldEnd()
    if self.instanceCount is not None:
      oprot.writeFieldBegin('instanceCount', TType.I32, 2)
      oprot.writeI32(self.instanceCount)
      oprot.writeFieldEnd()
    if self.settings is not None:
      oprot.writeFieldBegin('settings', TType.STRUCT, 3)
      self.settings.write(oprot)
      oprot.writeFieldEnd()
    if self.metadata is not None:
      oprot.writeFieldBegin('metadata', TType.SET, 4)
      oprot.writeSetBegin(TType.STRUCT, len(self.metadata))
      for iter220 in self.metadata:
        iter220.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class JobUpdateQuery(object):
  """
  Contains a set of restrictions on matching job updates where all restrictions must be met
  (terms are AND'ed together).

  Attributes:
   - role: Job role.
   - key: Unique identifier for a job update.
   - jobKey: Job key.
   - user: User who created the update.
   - updateStatuses: Set of update statuses.
   - offset: Offset to serve data from. Used by pagination.
   - limit: Number or records to serve. Used by pagination.
  """

  __slots__ = [ 
    'role',
    'jobKey',
    'user',
    'updateStatuses',
    'offset',
    'limit',
    'key',
   ]

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.STRING, 'role', None, None, ), # 2
    (3, TType.STRUCT, 'jobKey', (JobKey, JobKey.thrift_spec), None, ), # 3
    (4, TType.STRING, 'user', None, None, ), # 4
    (5, TType.SET, 'updateStatuses', (TType.I32,None), None, ), # 5
    (6, TType.I32, 'offset', None, None, ), # 6
    (7, TType.I32, 'limit', None, None, ), # 7
    (8, TType.STRUCT, 'key', (JobUpdateKey, JobUpdateKey.thrift_spec), None, ), # 8
  )

  def __init__(self, role=None, key=None, jobKey=None, user=None, updateStatuses=None, offset=None, limit=None,):
    self.role = role
    self.key = key
    self.jobKey = jobKey
    self.user = user
    self.updateStatuses = updateStatuses
    self.offset = offset
    self.limit = limit

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.STRING:
          self.role = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.key = JobUpdateKey()
          self.key.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.jobKey = JobKey()
          self.jobKey.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.user = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.SET:
          self.updateStatuses = set()
          (_etype224, _size221) = iprot.readSetBegin()
          for _i225 in xrange(_size221):
            _elem226 = iprot.readI32()
            self.updateStatuses.add(_elem226)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.offset = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.limit = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JobUpdateQuery')
    if self.role is not None:
      oprot.writeFieldBegin('role', TType.STRING, 2)
      oprot.writeString(self.role.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.jobKey is not None:
      oprot.writeFieldBegin('jobKey', TType.STRUCT, 3)
      self.jobKey.write(oprot)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 4)
      oprot.writeString(self.user.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.updateStatuses is not None:
      oprot.writeFieldBegin('updateStatuses', TType.SET, 5)
      oprot.writeSetBegin(TType.I32, len(self.updateStatuses))
      for iter227 in self.updateStatuses:
        oprot.writeI32(iter227)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.offset is not None:
      oprot.writeFieldBegin('offset', TType.I32, 6)
      oprot.writeI32(self.offset)
      oprot.writeFieldEnd()
    if self.limit is not None:
      oprot.writeFieldBegin('limit', TType.I32, 7)
      oprot.writeI32(self.limit)
      oprot.writeFieldEnd()
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRUCT, 8)
      self.key.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class ListBackupsResult(object):
  """
  Attributes:
   - backups
  """

  __slots__ = [ 
    'backups',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'backups', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, backups=None,):
    self.backups = backups

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.backups = set()
          (_etype231, _size228) = iprot.readSetBegin()
          for _i232 in xrange(_size228):
            _elem233 = iprot.readString().decode('utf-8')
            self.backups.add(_elem233)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ListBackupsResult')
    if self.backups is not None:
      oprot.writeFieldBegin('backups', TType.SET, 1)
      oprot.writeSetBegin(TType.STRING, len(self.backups))
      for iter234 in self.backups:
        oprot.writeString(iter234.encode('utf-8'))
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class StartMaintenanceResult(object):
  """
  Attributes:
   - statuses
  """

  __slots__ = [ 
    'statuses',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'statuses', (TType.STRUCT,(HostStatus, HostStatus.thrift_spec)), None, ), # 1
  )

  def __init__(self, statuses=None,):
    self.statuses = statuses

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.statuses = set()
          (_etype238, _size235) = iprot.readSetBegin()
          for _i239 in xrange(_size235):
            _elem240 = HostStatus()
            _elem240.read(iprot)
            self.statuses.add(_elem240)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StartMaintenanceResult')
    if self.statuses is not None:
      oprot.writeFieldBegin('statuses', TType.SET, 1)
      oprot.writeSetBegin(TType.STRUCT, len(self.statuses))
      for iter241 in self.statuses:
        iter241.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class DrainHostsResult(object):
  """
  Attributes:
   - statuses
  """

  __slots__ = [ 
    'statuses',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'statuses', (TType.STRUCT,(HostStatus, HostStatus.thrift_spec)), None, ), # 1
  )

  def __init__(self, statuses=None,):
    self.statuses = statuses

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.statuses = set()
          (_etype245, _size242) = iprot.readSetBegin()
          for _i246 in xrange(_size242):
            _elem247 = HostStatus()
            _elem247.read(iprot)
            self.statuses.add(_elem247)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DrainHostsResult')
    if self.statuses is not None:
      oprot.writeFieldBegin('statuses', TType.SET, 1)
      oprot.writeSetBegin(TType.STRUCT, len(self.statuses))
      for iter248 in self.statuses:
        iter248.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class QueryRecoveryResult(object):
  """
  Attributes:
   - tasks
  """

  __slots__ = [ 
    'tasks',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'tasks', (TType.STRUCT,(ScheduledTask, ScheduledTask.thrift_spec)), None, ), # 1
  )

  def __init__(self, tasks=None,):
    self.tasks = tasks

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.tasks = set()
          (_etype252, _size249) = iprot.readSetBegin()
          for _i253 in xrange(_size249):
            _elem254 = ScheduledTask()
            _elem254.read(iprot)
            self.tasks.add(_elem254)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('QueryRecoveryResult')
    if self.tasks is not None:
      oprot.writeFieldBegin('tasks', TType.SET, 1)
      oprot.writeSetBegin(TType.STRUCT, len(self.tasks))
      for iter255 in self.tasks:
        iter255.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class MaintenanceStatusResult(object):
  """
  Attributes:
   - statuses
  """

  __slots__ = [ 
    'statuses',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'statuses', (TType.STRUCT,(HostStatus, HostStatus.thrift_spec)), None, ), # 1
  )

  def __init__(self, statuses=None,):
    self.statuses = statuses

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.statuses = set()
          (_etype259, _size256) = iprot.readSetBegin()
          for _i260 in xrange(_size256):
            _elem261 = HostStatus()
            _elem261.read(iprot)
            self.statuses.add(_elem261)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MaintenanceStatusResult')
    if self.statuses is not None:
      oprot.writeFieldBegin('statuses', TType.SET, 1)
      oprot.writeSetBegin(TType.STRUCT, len(self.statuses))
      for iter262 in self.statuses:
        iter262.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class EndMaintenanceResult(object):
  """
  Attributes:
   - statuses
  """

  __slots__ = [ 
    'statuses',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'statuses', (TType.STRUCT,(HostStatus, HostStatus.thrift_spec)), None, ), # 1
  )

  def __init__(self, statuses=None,):
    self.statuses = statuses

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.statuses = set()
          (_etype266, _size263) = iprot.readSetBegin()
          for _i267 in xrange(_size263):
            _elem268 = HostStatus()
            _elem268.read(iprot)
            self.statuses.add(_elem268)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EndMaintenanceResult')
    if self.statuses is not None:
      oprot.writeFieldBegin('statuses', TType.SET, 1)
      oprot.writeSetBegin(TType.STRUCT, len(self.statuses))
      for iter269 in self.statuses:
        iter269.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class RoleSummaryResult(object):
  """
  Attributes:
   - summaries
  """

  __slots__ = [ 
    'summaries',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'summaries', (TType.STRUCT,(RoleSummary, RoleSummary.thrift_spec)), None, ), # 1
  )

  def __init__(self, summaries=None,):
    self.summaries = summaries

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.summaries = set()
          (_etype273, _size270) = iprot.readSetBegin()
          for _i274 in xrange(_size270):
            _elem275 = RoleSummary()
            _elem275.read(iprot)
            self.summaries.add(_elem275)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RoleSummaryResult')
    if self.summaries is not None:
      oprot.writeFieldBegin('summaries', TType.SET, 1)
      oprot.writeSetBegin(TType.STRUCT, len(self.summaries))
      for iter276 in self.summaries:
        iter276.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class JobSummaryResult(object):
  """
  Attributes:
   - summaries
  """

  __slots__ = [ 
    'summaries',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'summaries', (TType.STRUCT,(JobSummary, JobSummary.thrift_spec)), None, ), # 1
  )

  def __init__(self, summaries=None,):
    self.summaries = summaries

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.summaries = set()
          (_etype280, _size277) = iprot.readSetBegin()
          for _i281 in xrange(_size277):
            _elem282 = JobSummary()
            _elem282.read(iprot)
            self.summaries.add(_elem282)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JobSummaryResult')
    if self.summaries is not None:
      oprot.writeFieldBegin('summaries', TType.SET, 1)
      oprot.writeSetBegin(TType.STRUCT, len(self.summaries))
      for iter283 in self.summaries:
        iter283.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class ConfigSummaryResult(object):
  """
  Attributes:
   - summary
  """

  __slots__ = [ 
    'summary',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'summary', (ConfigSummary, ConfigSummary.thrift_spec), None, ), # 1
  )

  def __init__(self, summary=None,):
    self.summary = summary

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.summary = ConfigSummary()
          self.summary.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ConfigSummaryResult')
    if self.summary is not None:
      oprot.writeFieldBegin('summary', TType.STRUCT, 1)
      self.summary.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class GetPendingReasonResult(object):
  """
  Attributes:
   - reasons
  """

  __slots__ = [ 
    'reasons',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'reasons', (TType.STRUCT,(PendingReason, PendingReason.thrift_spec)), None, ), # 1
  )

  def __init__(self, reasons=None,):
    self.reasons = reasons

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.reasons = set()
          (_etype287, _size284) = iprot.readSetBegin()
          for _i288 in xrange(_size284):
            _elem289 = PendingReason()
            _elem289.read(iprot)
            self.reasons.add(_elem289)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetPendingReasonResult')
    if self.reasons is not None:
      oprot.writeFieldBegin('reasons', TType.SET, 1)
      oprot.writeSetBegin(TType.STRUCT, len(self.reasons))
      for iter290 in self.reasons:
        iter290.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class StartJobUpdateResult(object):
  """
  Result of the startUpdate call.

  Attributes:
   - key: Unique identifier for the job update.
   - updateSummary: Summary of the update that is in progress for the given JobKey.
  """

  __slots__ = [ 
    'key',
    'updateSummary',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'key', (JobUpdateKey, JobUpdateKey.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'updateSummary', (JobUpdateSummary, JobUpdateSummary.thrift_spec), None, ), # 2
  )

  def __init__(self, key=None, updateSummary=None,):
    self.key = key
    self.updateSummary = updateSummary

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.key = JobUpdateKey()
          self.key.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.updateSummary = JobUpdateSummary()
          self.updateSummary.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StartJobUpdateResult')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRUCT, 1)
      self.key.write(oprot)
      oprot.writeFieldEnd()
    if self.updateSummary is not None:
      oprot.writeFieldBegin('updateSummary', TType.STRUCT, 2)
      self.updateSummary.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class GetJobUpdateSummariesResult(object):
  """
  Result of the getJobUpdateSummaries call.

  Attributes:
   - updateSummaries
  """

  __slots__ = [ 
    'updateSummaries',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'updateSummaries', (TType.STRUCT,(JobUpdateSummary, JobUpdateSummary.thrift_spec)), None, ), # 1
  )

  def __init__(self, updateSummaries=None,):
    self.updateSummaries = updateSummaries

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.updateSummaries = []
          (_etype294, _size291) = iprot.readListBegin()
          for _i295 in xrange(_size291):
            _elem296 = JobUpdateSummary()
            _elem296.read(iprot)
            self.updateSummaries.append(_elem296)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetJobUpdateSummariesResult')
    if self.updateSummaries is not None:
      oprot.writeFieldBegin('updateSummaries', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.updateSummaries))
      for iter297 in self.updateSummaries:
        iter297.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class GetJobUpdateDetailsResult(object):
  """
  Result of the getJobUpdateDetails call.

  Attributes:
   - details
   - detailsList
  """

  __slots__ = [ 
    'details',
    'detailsList',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'details', (JobUpdateDetails, JobUpdateDetails.thrift_spec), None, ), # 1
    (2, TType.LIST, 'detailsList', (TType.STRUCT,(JobUpdateDetails, JobUpdateDetails.thrift_spec)), None, ), # 2
  )

  def __init__(self, details=None, detailsList=None,):
    self.details = details
    self.detailsList = detailsList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.details = JobUpdateDetails()
          self.details.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.detailsList = []
          (_etype301, _size298) = iprot.readListBegin()
          for _i302 in xrange(_size298):
            _elem303 = JobUpdateDetails()
            _elem303.read(iprot)
            self.detailsList.append(_elem303)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetJobUpdateDetailsResult')
    if self.details is not None:
      oprot.writeFieldBegin('details', TType.STRUCT, 1)
      self.details.write(oprot)
      oprot.writeFieldEnd()
    if self.detailsList is not None:
      oprot.writeFieldBegin('detailsList', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.detailsList))
      for iter304 in self.detailsList:
        iter304.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class PulseJobUpdateResult(object):
  """
  Result of the pulseJobUpdate call.

  Attributes:
   - status
  """

  __slots__ = [ 
    'status',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'status', None, None, ), # 1
  )

  def __init__(self, status=None,):
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.status = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PulseJobUpdateResult')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.I32, 1)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class GetJobUpdateDiffResult(object):
  """
  Attributes:
   - add: Instance addition diff details.
   - remove: Instance removal diff details.
   - update: Instance update diff details.
   - unchanged: Instances unchanged by the update.
  """

  __slots__ = [ 
    'add',
    'remove',
    'update',
    'unchanged',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'add', (TType.STRUCT,(ConfigGroup, ConfigGroup.thrift_spec)), None, ), # 1
    (2, TType.SET, 'remove', (TType.STRUCT,(ConfigGroup, ConfigGroup.thrift_spec)), None, ), # 2
    (3, TType.SET, 'update', (TType.STRUCT,(ConfigGroup, ConfigGroup.thrift_spec)), None, ), # 3
    (4, TType.SET, 'unchanged', (TType.STRUCT,(ConfigGroup, ConfigGroup.thrift_spec)), None, ), # 4
  )

  def __init__(self, add=None, remove=None, update=None, unchanged=None,):
    self.add = add
    self.remove = remove
    self.update = update
    self.unchanged = unchanged

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.add = set()
          (_etype308, _size305) = iprot.readSetBegin()
          for _i309 in xrange(_size305):
            _elem310 = ConfigGroup()
            _elem310.read(iprot)
            self.add.add(_elem310)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.SET:
          self.remove = set()
          (_etype314, _size311) = iprot.readSetBegin()
          for _i315 in xrange(_size311):
            _elem316 = ConfigGroup()
            _elem316.read(iprot)
            self.remove.add(_elem316)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.SET:
          self.update = set()
          (_etype320, _size317) = iprot.readSetBegin()
          for _i321 in xrange(_size317):
            _elem322 = ConfigGroup()
            _elem322.read(iprot)
            self.update.add(_elem322)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.SET:
          self.unchanged = set()
          (_etype326, _size323) = iprot.readSetBegin()
          for _i327 in xrange(_size323):
            _elem328 = ConfigGroup()
            _elem328.read(iprot)
            self.unchanged.add(_elem328)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetJobUpdateDiffResult')
    if self.add is not None:
      oprot.writeFieldBegin('add', TType.SET, 1)
      oprot.writeSetBegin(TType.STRUCT, len(self.add))
      for iter329 in self.add:
        iter329.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.remove is not None:
      oprot.writeFieldBegin('remove', TType.SET, 2)
      oprot.writeSetBegin(TType.STRUCT, len(self.remove))
      for iter330 in self.remove:
        iter330.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.update is not None:
      oprot.writeFieldBegin('update', TType.SET, 3)
      oprot.writeSetBegin(TType.STRUCT, len(self.update))
      for iter331 in self.update:
        iter331.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.unchanged is not None:
      oprot.writeFieldBegin('unchanged', TType.SET, 4)
      oprot.writeSetBegin(TType.STRUCT, len(self.unchanged))
      for iter332 in self.unchanged:
        iter332.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class TierConfig(object):
  """
  Tier information.

  Attributes:
   - name: Name of tier.
   - settings: Tier attributes.
  """

  __slots__ = [ 
    'name',
    'settings',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.MAP, 'settings', (TType.STRING,None,TType.STRING,None), None, ), # 2
  )

  def __init__(self, name=None, settings=None,):
    self.name = name
    self.settings = settings

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.settings = {}
          (_ktype334, _vtype335, _size333 ) = iprot.readMapBegin()
          for _i337 in xrange(_size333):
            _key338 = iprot.readString().decode('utf-8')
            _val339 = iprot.readString().decode('utf-8')
            self.settings[_key338] = _val339
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TierConfig')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.settings is not None:
      oprot.writeFieldBegin('settings', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.settings))
      for kiter340,viter341 in self.settings.items():
        oprot.writeString(kiter340.encode('utf-8'))
        oprot.writeString(viter341.encode('utf-8'))
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class GetTierConfigResult(object):
  """
  Result of the getTierConfigResult call.

  Attributes:
   - defaultTierName: Name of the default tier.
   - tiers: Set of tier configurations.
  """

  __slots__ = [ 
    'defaultTierName',
    'tiers',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'defaultTierName', None, None, ), # 1
    (2, TType.SET, 'tiers', (TType.STRUCT,(TierConfig, TierConfig.thrift_spec)), None, ), # 2
  )

  def __init__(self, defaultTierName=None, tiers=None,):
    self.defaultTierName = defaultTierName
    self.tiers = tiers

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.defaultTierName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.SET:
          self.tiers = set()
          (_etype345, _size342) = iprot.readSetBegin()
          for _i346 in xrange(_size342):
            _elem347 = TierConfig()
            _elem347.read(iprot)
            self.tiers.add(_elem347)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetTierConfigResult')
    if self.defaultTierName is not None:
      oprot.writeFieldBegin('defaultTierName', TType.STRING, 1)
      oprot.writeString(self.defaultTierName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.tiers is not None:
      oprot.writeFieldBegin('tiers', TType.SET, 2)
      oprot.writeSetBegin(TType.STRUCT, len(self.tiers))
      for iter348 in self.tiers:
        iter348.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class ServerInfo(object):
  """
  Information about the scheduler.

  Attributes:
   - clusterName
   - statsUrlPrefix: A url prefix for job container stats.
  """

  __slots__ = [ 
    'clusterName',
    'statsUrlPrefix',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'clusterName', None, None, ), # 1
    None, # 2
    (3, TType.STRING, 'statsUrlPrefix', None, None, ), # 3
  )

  def __init__(self, clusterName=None, statsUrlPrefix=None,):
    self.clusterName = clusterName
    self.statsUrlPrefix = statsUrlPrefix

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.clusterName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.statsUrlPrefix = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ServerInfo')
    if self.clusterName is not None:
      oprot.writeFieldBegin('clusterName', TType.STRING, 1)
      oprot.writeString(self.clusterName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.statsUrlPrefix is not None:
      oprot.writeFieldBegin('statsUrlPrefix', TType.STRING, 3)
      oprot.writeString(self.statsUrlPrefix.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class Result(object):
  """
  Attributes:
   - populateJobResult
   - scheduleStatusResult
   - getJobsResult
   - getQuotaResult
   - listBackupsResult
   - startMaintenanceResult
   - drainHostsResult
   - queryRecoveryResult
   - maintenanceStatusResult
   - endMaintenanceResult
   - roleSummaryResult
   - jobSummaryResult
   - configSummaryResult
   - getPendingReasonResult
   - startJobUpdateResult
   - getJobUpdateSummariesResult
   - getJobUpdateDetailsResult
   - pulseJobUpdateResult
   - getJobUpdateDiffResult
   - getTierConfigResult
  """

  __slots__ = [ 
    'populateJobResult',
    'scheduleStatusResult',
    'getJobsResult',
    'getQuotaResult',
    'listBackupsResult',
    'startMaintenanceResult',
    'drainHostsResult',
    'queryRecoveryResult',
    'maintenanceStatusResult',
    'endMaintenanceResult',
    'roleSummaryResult',
    'jobSummaryResult',
    'configSummaryResult',
    'getPendingReasonResult',
    'startJobUpdateResult',
    'getJobUpdateSummariesResult',
    'getJobUpdateDetailsResult',
    'pulseJobUpdateResult',
    'getJobUpdateDiffResult',
    'getTierConfigResult',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'populateJobResult', (PopulateJobResult, PopulateJobResult.thrift_spec), None, ), # 1
    None, # 2
    (3, TType.STRUCT, 'scheduleStatusResult', (ScheduleStatusResult, ScheduleStatusResult.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'getJobsResult', (GetJobsResult, GetJobsResult.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'getQuotaResult', (GetQuotaResult, GetQuotaResult.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'listBackupsResult', (ListBackupsResult, ListBackupsResult.thrift_spec), None, ), # 6
    (7, TType.STRUCT, 'startMaintenanceResult', (StartMaintenanceResult, StartMaintenanceResult.thrift_spec), None, ), # 7
    (8, TType.STRUCT, 'drainHostsResult', (DrainHostsResult, DrainHostsResult.thrift_spec), None, ), # 8
    (9, TType.STRUCT, 'queryRecoveryResult', (QueryRecoveryResult, QueryRecoveryResult.thrift_spec), None, ), # 9
    (10, TType.STRUCT, 'maintenanceStatusResult', (MaintenanceStatusResult, MaintenanceStatusResult.thrift_spec), None, ), # 10
    (11, TType.STRUCT, 'endMaintenanceResult', (EndMaintenanceResult, EndMaintenanceResult.thrift_spec), None, ), # 11
    None, # 12
    None, # 13
    None, # 14
    None, # 15
    None, # 16
    (17, TType.STRUCT, 'roleSummaryResult', (RoleSummaryResult, RoleSummaryResult.thrift_spec), None, ), # 17
    (18, TType.STRUCT, 'jobSummaryResult', (JobSummaryResult, JobSummaryResult.thrift_spec), None, ), # 18
    None, # 19
    (20, TType.STRUCT, 'configSummaryResult', (ConfigSummaryResult, ConfigSummaryResult.thrift_spec), None, ), # 20
    (21, TType.STRUCT, 'getPendingReasonResult', (GetPendingReasonResult, GetPendingReasonResult.thrift_spec), None, ), # 21
    (22, TType.STRUCT, 'startJobUpdateResult', (StartJobUpdateResult, StartJobUpdateResult.thrift_spec), None, ), # 22
    (23, TType.STRUCT, 'getJobUpdateSummariesResult', (GetJobUpdateSummariesResult, GetJobUpdateSummariesResult.thrift_spec), None, ), # 23
    (24, TType.STRUCT, 'getJobUpdateDetailsResult', (GetJobUpdateDetailsResult, GetJobUpdateDetailsResult.thrift_spec), None, ), # 24
    (25, TType.STRUCT, 'pulseJobUpdateResult', (PulseJobUpdateResult, PulseJobUpdateResult.thrift_spec), None, ), # 25
    (26, TType.STRUCT, 'getJobUpdateDiffResult', (GetJobUpdateDiffResult, GetJobUpdateDiffResult.thrift_spec), None, ), # 26
    (27, TType.STRUCT, 'getTierConfigResult', (GetTierConfigResult, GetTierConfigResult.thrift_spec), None, ), # 27
  )

  def __init__(self, populateJobResult=None, scheduleStatusResult=None, getJobsResult=None, getQuotaResult=None, listBackupsResult=None, startMaintenanceResult=None, drainHostsResult=None, queryRecoveryResult=None, maintenanceStatusResult=None, endMaintenanceResult=None, roleSummaryResult=None, jobSummaryResult=None, configSummaryResult=None, getPendingReasonResult=None, startJobUpdateResult=None, getJobUpdateSummariesResult=None, getJobUpdateDetailsResult=None, pulseJobUpdateResult=None, getJobUpdateDiffResult=None, getTierConfigResult=None,):
    self.populateJobResult = populateJobResult
    self.scheduleStatusResult = scheduleStatusResult
    self.getJobsResult = getJobsResult
    self.getQuotaResult = getQuotaResult
    self.listBackupsResult = listBackupsResult
    self.startMaintenanceResult = startMaintenanceResult
    self.drainHostsResult = drainHostsResult
    self.queryRecoveryResult = queryRecoveryResult
    self.maintenanceStatusResult = maintenanceStatusResult
    self.endMaintenanceResult = endMaintenanceResult
    self.roleSummaryResult = roleSummaryResult
    self.jobSummaryResult = jobSummaryResult
    self.configSummaryResult = configSummaryResult
    self.getPendingReasonResult = getPendingReasonResult
    self.startJobUpdateResult = startJobUpdateResult
    self.getJobUpdateSummariesResult = getJobUpdateSummariesResult
    self.getJobUpdateDetailsResult = getJobUpdateDetailsResult
    self.pulseJobUpdateResult = pulseJobUpdateResult
    self.getJobUpdateDiffResult = getJobUpdateDiffResult
    self.getTierConfigResult = getTierConfigResult

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.populateJobResult = PopulateJobResult()
          self.populateJobResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.scheduleStatusResult = ScheduleStatusResult()
          self.scheduleStatusResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.getJobsResult = GetJobsResult()
          self.getJobsResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.getQuotaResult = GetQuotaResult()
          self.getQuotaResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.listBackupsResult = ListBackupsResult()
          self.listBackupsResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.startMaintenanceResult = StartMaintenanceResult()
          self.startMaintenanceResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.drainHostsResult = DrainHostsResult()
          self.drainHostsResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.queryRecoveryResult = QueryRecoveryResult()
          self.queryRecoveryResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.maintenanceStatusResult = MaintenanceStatusResult()
          self.maintenanceStatusResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          self.endMaintenanceResult = EndMaintenanceResult()
          self.endMaintenanceResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.STRUCT:
          self.roleSummaryResult = RoleSummaryResult()
          self.roleSummaryResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.STRUCT:
          self.jobSummaryResult = JobSummaryResult()
          self.jobSummaryResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.STRUCT:
          self.configSummaryResult = ConfigSummaryResult()
          self.configSummaryResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 21:
        if ftype == TType.STRUCT:
          self.getPendingReasonResult = GetPendingReasonResult()
          self.getPendingReasonResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 22:
        if ftype == TType.STRUCT:
          self.startJobUpdateResult = StartJobUpdateResult()
          self.startJobUpdateResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 23:
        if ftype == TType.STRUCT:
          self.getJobUpdateSummariesResult = GetJobUpdateSummariesResult()
          self.getJobUpdateSummariesResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 24:
        if ftype == TType.STRUCT:
          self.getJobUpdateDetailsResult = GetJobUpdateDetailsResult()
          self.getJobUpdateDetailsResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 25:
        if ftype == TType.STRUCT:
          self.pulseJobUpdateResult = PulseJobUpdateResult()
          self.pulseJobUpdateResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 26:
        if ftype == TType.STRUCT:
          self.getJobUpdateDiffResult = GetJobUpdateDiffResult()
          self.getJobUpdateDiffResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 27:
        if ftype == TType.STRUCT:
          self.getTierConfigResult = GetTierConfigResult()
          self.getTierConfigResult.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Result')
    if self.populateJobResult is not None:
      oprot.writeFieldBegin('populateJobResult', TType.STRUCT, 1)
      self.populateJobResult.write(oprot)
      oprot.writeFieldEnd()
    if self.scheduleStatusResult is not None:
      oprot.writeFieldBegin('scheduleStatusResult', TType.STRUCT, 3)
      self.scheduleStatusResult.write(oprot)
      oprot.writeFieldEnd()
    if self.getJobsResult is not None:
      oprot.writeFieldBegin('getJobsResult', TType.STRUCT, 4)
      self.getJobsResult.write(oprot)
      oprot.writeFieldEnd()
    if self.getQuotaResult is not None:
      oprot.writeFieldBegin('getQuotaResult', TType.STRUCT, 5)
      self.getQuotaResult.write(oprot)
      oprot.writeFieldEnd()
    if self.listBackupsResult is not None:
      oprot.writeFieldBegin('listBackupsResult', TType.STRUCT, 6)
      self.listBackupsResult.write(oprot)
      oprot.writeFieldEnd()
    if self.startMaintenanceResult is not None:
      oprot.writeFieldBegin('startMaintenanceResult', TType.STRUCT, 7)
      self.startMaintenanceResult.write(oprot)
      oprot.writeFieldEnd()
    if self.drainHostsResult is not None:
      oprot.writeFieldBegin('drainHostsResult', TType.STRUCT, 8)
      self.drainHostsResult.write(oprot)
      oprot.writeFieldEnd()
    if self.queryRecoveryResult is not None:
      oprot.writeFieldBegin('queryRecoveryResult', TType.STRUCT, 9)
      self.queryRecoveryResult.write(oprot)
      oprot.writeFieldEnd()
    if self.maintenanceStatusResult is not None:
      oprot.writeFieldBegin('maintenanceStatusResult', TType.STRUCT, 10)
      self.maintenanceStatusResult.write(oprot)
      oprot.writeFieldEnd()
    if self.endMaintenanceResult is not None:
      oprot.writeFieldBegin('endMaintenanceResult', TType.STRUCT, 11)
      self.endMaintenanceResult.write(oprot)
      oprot.writeFieldEnd()
    if self.roleSummaryResult is not None:
      oprot.writeFieldBegin('roleSummaryResult', TType.STRUCT, 17)
      self.roleSummaryResult.write(oprot)
      oprot.writeFieldEnd()
    if self.jobSummaryResult is not None:
      oprot.writeFieldBegin('jobSummaryResult', TType.STRUCT, 18)
      self.jobSummaryResult.write(oprot)
      oprot.writeFieldEnd()
    if self.configSummaryResult is not None:
      oprot.writeFieldBegin('configSummaryResult', TType.STRUCT, 20)
      self.configSummaryResult.write(oprot)
      oprot.writeFieldEnd()
    if self.getPendingReasonResult is not None:
      oprot.writeFieldBegin('getPendingReasonResult', TType.STRUCT, 21)
      self.getPendingReasonResult.write(oprot)
      oprot.writeFieldEnd()
    if self.startJobUpdateResult is not None:
      oprot.writeFieldBegin('startJobUpdateResult', TType.STRUCT, 22)
      self.startJobUpdateResult.write(oprot)
      oprot.writeFieldEnd()
    if self.getJobUpdateSummariesResult is not None:
      oprot.writeFieldBegin('getJobUpdateSummariesResult', TType.STRUCT, 23)
      self.getJobUpdateSummariesResult.write(oprot)
      oprot.writeFieldEnd()
    if self.getJobUpdateDetailsResult is not None:
      oprot.writeFieldBegin('getJobUpdateDetailsResult', TType.STRUCT, 24)
      self.getJobUpdateDetailsResult.write(oprot)
      oprot.writeFieldEnd()
    if self.pulseJobUpdateResult is not None:
      oprot.writeFieldBegin('pulseJobUpdateResult', TType.STRUCT, 25)
      self.pulseJobUpdateResult.write(oprot)
      oprot.writeFieldEnd()
    if self.getJobUpdateDiffResult is not None:
      oprot.writeFieldBegin('getJobUpdateDiffResult', TType.STRUCT, 26)
      self.getJobUpdateDiffResult.write(oprot)
      oprot.writeFieldEnd()
    if self.getTierConfigResult is not None:
      oprot.writeFieldBegin('getTierConfigResult', TType.STRUCT, 27)
      self.getTierConfigResult.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class ResponseDetail(object):
  """
  Attributes:
   - message
  """

  __slots__ = [ 
    'message',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ResponseDetail')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class Response(object):
  """
  Attributes:
   - responseCode
   - serverInfo
   - result: Payload from the invoked RPC.
   - details: Messages from the server relevant to the request, such as warnings or use of deprecated
  features.
  """

  __slots__ = [ 
    'responseCode',
    'result',
    'serverInfo',
    'details',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'responseCode', None, None, ), # 1
    None, # 2
    (3, TType.STRUCT, 'result', (Result, Result.thrift_spec), None, ), # 3
    None, # 4
    (5, TType.STRUCT, 'serverInfo', (ServerInfo, ServerInfo.thrift_spec), None, ), # 5
    (6, TType.LIST, 'details', (TType.STRUCT,(ResponseDetail, ResponseDetail.thrift_spec)), None, ), # 6
  )

  def __init__(self, responseCode=None, serverInfo=None, result=None, details=None,):
    self.responseCode = responseCode
    self.serverInfo = serverInfo
    self.result = result
    self.details = details

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.responseCode = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.serverInfo = ServerInfo()
          self.serverInfo.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.result = Result()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.details = []
          (_etype352, _size349) = iprot.readListBegin()
          for _i353 in xrange(_size349):
            _elem354 = ResponseDetail()
            _elem354.read(iprot)
            self.details.append(_elem354)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Response')
    if self.responseCode is not None:
      oprot.writeFieldBegin('responseCode', TType.I32, 1)
      oprot.writeI32(self.responseCode)
      oprot.writeFieldEnd()
    if self.result is not None:
      oprot.writeFieldBegin('result', TType.STRUCT, 3)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.serverInfo is not None:
      oprot.writeFieldBegin('serverInfo', TType.STRUCT, 5)
      self.serverInfo.write(oprot)
      oprot.writeFieldEnd()
    if self.details is not None:
      oprot.writeFieldBegin('details', TType.LIST, 6)
      oprot.writeListBegin(TType.STRUCT, len(self.details))
      for iter355 in self.details:
        iter355.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class InstanceConfigRewrite(object):
  """
  Attributes:
   - instanceKey: Key for the task to rewrite.
   - oldTask: The original configuration.
   - rewrittenTask: The rewritten configuration.
  """

  __slots__ = [ 
    'instanceKey',
    'oldTask',
    'rewrittenTask',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'instanceKey', (InstanceKey, InstanceKey.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'oldTask', (TaskConfig, TaskConfig.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'rewrittenTask', (TaskConfig, TaskConfig.thrift_spec), None, ), # 3
  )

  def __init__(self, instanceKey=None, oldTask=None, rewrittenTask=None,):
    self.instanceKey = instanceKey
    self.oldTask = oldTask
    self.rewrittenTask = rewrittenTask

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.instanceKey = InstanceKey()
          self.instanceKey.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.oldTask = TaskConfig()
          self.oldTask.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.rewrittenTask = TaskConfig()
          self.rewrittenTask.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InstanceConfigRewrite')
    if self.instanceKey is not None:
      oprot.writeFieldBegin('instanceKey', TType.STRUCT, 1)
      self.instanceKey.write(oprot)
      oprot.writeFieldEnd()
    if self.oldTask is not None:
      oprot.writeFieldBegin('oldTask', TType.STRUCT, 2)
      self.oldTask.write(oprot)
      oprot.writeFieldEnd()
    if self.rewrittenTask is not None:
      oprot.writeFieldBegin('rewrittenTask', TType.STRUCT, 3)
      self.rewrittenTask.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class JobConfigRewrite(object):
  """
  Attributes:
   - oldJob: The original job configuration.
   - rewrittenJob: The rewritten job configuration.
  """

  __slots__ = [ 
    'oldJob',
    'rewrittenJob',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'oldJob', (JobConfiguration, JobConfiguration.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'rewrittenJob', (JobConfiguration, JobConfiguration.thrift_spec), None, ), # 2
  )

  def __init__(self, oldJob=None, rewrittenJob=None,):
    self.oldJob = oldJob
    self.rewrittenJob = rewrittenJob

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.oldJob = JobConfiguration()
          self.oldJob.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.rewrittenJob = JobConfiguration()
          self.rewrittenJob.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JobConfigRewrite')
    if self.oldJob is not None:
      oprot.writeFieldBegin('oldJob', TType.STRUCT, 1)
      self.oldJob.write(oprot)
      oprot.writeFieldEnd()
    if self.rewrittenJob is not None:
      oprot.writeFieldBegin('rewrittenJob', TType.STRUCT, 2)
      self.rewrittenJob.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class ConfigRewrite(object):
  """
  Attributes:
   - jobRewrite
   - instanceRewrite
  """

  __slots__ = [ 
    'jobRewrite',
    'instanceRewrite',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'jobRewrite', (JobConfigRewrite, JobConfigRewrite.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'instanceRewrite', (InstanceConfigRewrite, InstanceConfigRewrite.thrift_spec), None, ), # 2
  )

  def __init__(self, jobRewrite=None, instanceRewrite=None,):
    self.jobRewrite = jobRewrite
    self.instanceRewrite = instanceRewrite

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.jobRewrite = JobConfigRewrite()
          self.jobRewrite.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.instanceRewrite = InstanceConfigRewrite()
          self.instanceRewrite.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ConfigRewrite')
    if self.jobRewrite is not None:
      oprot.writeFieldBegin('jobRewrite', TType.STRUCT, 1)
      self.jobRewrite.write(oprot)
      oprot.writeFieldEnd()
    if self.instanceRewrite is not None:
      oprot.writeFieldBegin('instanceRewrite', TType.STRUCT, 2)
      self.instanceRewrite.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class RewriteConfigsRequest(object):
  """
  Attributes:
   - rewriteCommands
  """

  __slots__ = [ 
    'rewriteCommands',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'rewriteCommands', (TType.STRUCT,(ConfigRewrite, ConfigRewrite.thrift_spec)), None, ), # 1
  )

  def __init__(self, rewriteCommands=None,):
    self.rewriteCommands = rewriteCommands

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.rewriteCommands = []
          (_etype359, _size356) = iprot.readListBegin()
          for _i360 in xrange(_size356):
            _elem361 = ConfigRewrite()
            _elem361.read(iprot)
            self.rewriteCommands.append(_elem361)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RewriteConfigsRequest')
    if self.rewriteCommands is not None:
      oprot.writeFieldBegin('rewriteCommands', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.rewriteCommands))
      for iter362 in self.rewriteCommands:
        iter362.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class ExplicitReconciliationSettings(object):
  """
  Attributes:
   - batchSize
  """

  __slots__ = [ 
    'batchSize',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'batchSize', None, None, ), # 1
  )

  def __init__(self, batchSize=None,):
    self.batchSize = batchSize

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.batchSize = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ExplicitReconciliationSettings')
    if self.batchSize is not None:
      oprot.writeFieldBegin('batchSize', TType.I32, 1)
      oprot.writeI32(self.batchSize)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return



  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)

